# Parse Tree Matching and XPath
# 解析树匹配与 XPath

[原文链接](https://github.com/antlr/antlr4/blob/master/doc/tree-matching.md)

*Since ANTLR 4.2*
*自 ANTLR 4.2 起*

ANTLR 4 introduced a visitor and listener mechanism that lets you implement DOM visiting or SAX-analogous event processing of tree nodes. This works great. For example, if all you care about is looking at Java method declarations, grab the `Java.g4` file and then override methodDeclaration in `JavaBaseListener`. From there, a `ParseTreeWalker` can trigger calls to your overridden method as it walks the tree. Easy things are easy.
ANTLR 4 引入了访问者和监听器机制，让您能够实现 DOM 遍历或类似 SAX 的树节点事件处理。这非常有效。例如，如果您只关心查看 Java 方法声明，可以获取 `Java.g4` 文件，然后在 `JavaBaseListener` 中重写 methodDeclaration。之后，`ParseTreeWalker` 在遍历树时可以触发对您重写的方法的调用。简单的事情变得简单。

This mechanism works more or less on a node-level basis. In other words, for every method declaration subtree root, your `methodDeclaration()` would get called. There are many situations where we care more about subtrees not just nodes. We might want to:
这种机制或多或少是在节点级别上工作的。换句话说，对于每个方法声明子树根，您的 `methodDeclaration()` 都会被调用。但在许多情况下，我们更关心的是子树而不仅仅是节点。我们可能希望：

* Collect method declarations within a particular context (i.e., nested within another method) or methods with specific structure or specific types (e.g., `void <ID>() { }`). We'll combine `XPath` and tree pattern matching for this.
* Group translation operations by patterns in the tree rather than spreading operations across listener event methods.
* Get a list of all assignments anywhere in the tree. It's much easier to say *go find me all "... = ... ;" subtrees* rather than creating a class just to get a listener method for rule assignment and then passing the listener to the parse tree walker.
* 在特定上下文（例如，嵌套在另一个方法内）中收集方法声明，或收集具有特定结构或特定类型的方法（例如 `void <ID>() { }`）。我们将结合使用 `XPath` 和树模式匹配来实现这一点。
* 根据树中的模式对翻译操作进行分组，而不是将操作分散到各个监听器事件方法中。
* 获取树中所有赋值语句的列表。直接说*"给我找到所有 '... = ... ;' 子树"*要比专门创建一个类来获取规则赋值的监听器方法，然后将监听器传递给解析树遍历器容易得多。

The other important idea here is that, since we're talking about parse trees not abstract syntax trees, we can use concrete patterns instead of tree syntax. For example, we can say `x = 0;` instead of AST `(= x 0)` where the `;` would probably stripped before it went into the AST.
另一个重要的想法是，由于我们讨论的是解析树而不是抽象语法树，我们可以使用具体模式而不是树语法。例如，我们可以说 `x = 0;` 而不是 AST 中的 `(= x 0)`，其中 `;` 可能在进入 AST 之前就被去掉了。

## Parse tree patterns
## 解析树模式

To test a subtree to see if it has a particular structure, we use a tree pattern. We also often want to extract descendents from the subtree based upon the structure. A very simple example is checking to see if a subtree matches an assignment statement. The pattern might look like the following in your language:
为了测试子树是否具有特定结构，我们使用树模式。我们还经常希望基于结构从子树中提取后代。一个非常简单的例子是检查子树是否匹配赋值语句。在您的语言中，模式可能如下所示：

```
<ID> = <expr>;
```

where "tags" in angle brackets represent either token or rule references in the associated grammar. ANTLR converts that string to a parse tree with special nodes that represent any token `ID` and rule `expr` subtree. To create this parse tree, the pattern matching compiler needs to know which rule in the grammar the pattern conforms to. In this case it might be statement. Here is how we could test a tree, `t`, to see if it matches that pattern:
其中尖括号中的"标签"表示关联语法中的词法符号或规则引用。ANTLR 将该字符串转换为解析树，其中包含表示任何词法符号 `ID` 和规则 `expr` 子树的特殊节点。要创建此解析树，模式匹配编译器需要知道模式符合语法中的哪个规则。在这种情况下，可能是 statement。以下是我们如何测试树 `t` 是否匹配该模式的方法：

```java
ParseTree t = ...; // assume t is a statement
ParseTreePattern p = parser.compileParseTreePattern("<ID> = <expr>;", MyParser.RULE_statement);
ParseTreeMatch m = p.match(t);
if ( m.succeeded() ) {...}
```

We can also test for specific expressions or token values. For example, the following checks to see if `t` is an expression consisting of an identifier added to 0:
我们还可以测试特定的表达式或词法符号值。例如，以下代码检查 `t` 是否是一个由标识符加 0 组成的表达式：

```java
ParseTree t = ...; // assume t is an expression
ParseTreePattern p = parser.compileParseTreePattern("<ID>+0", MyParser.RULE_expr);
ParseTreeMatch m = p.match(t);
```

We can also ask the `ParseTreeMatch` result to pull out the token matched to the `<ID>` tag:
我们还可以要求 `ParseTreeMatch` 结果提取与 `<ID>` 标签匹配的词法符号：

```java
String id = m.get("ID");
```

You can change the tag delimiters using a method on the pattern matcher:
您可以使用模式匹配器上的方法更改标签分隔符：

```java
ParseTreePatternMatcher m = new ParseTreePatternMatcher();
m.setDelimiters("<<", ">>", "$"); // $ is the escape character
```

This would allow pattern `<<ID>> = <<expr>> ;$<< ick $>>` to be interpreted as elements: `ID`, ` = `, `expr`, and ` ;<< ick >>`.
这将允许模式 `<<ID>> = <<expr>> ;$<< ick $>>` 被解释为元素：`ID`、` = `、`expr` 和 ` ;<< ick >>`。

### Pattern labels
### 模式标签

The tree pattern matcher tracks the nodes in the tree at matches against the tags in a tree pattern. That way we can use the `get()` and `getAll()` methods to retrieve components of the matched subtree. For example, for pattern `<ID>`, `get("ID")` returns the node matched for that `ID`. If more than one node matched the specified token or rule tag, only the first match is returned. If there is no node associated with the label, this returns null.
树模式匹配器跟踪树中与树模式中的标签匹配的节点。这样我们就可以使用 `get()` 和 `getAll()` 方法来检索匹配子树的组件。例如，对于模式 `<ID>`，`get("ID")` 返回与该 `ID` 匹配的节点。如果有多个节点匹配指定的词法符号或规则标签，则只返回第一个匹配项。如果没有与标签关联的节点，则返回 null。

You can also label the tags with identifiers. If the label is the name of a parser rule or token in the grammar, the resulting list from `getAll()` (or node from `get()`) will contain both the parse trees matching rule or tags explicitly labeled with the label and the complete set of parse trees matching the labeled and unlabeled tags in the pattern for the parser rule or token. For example, if label is `foo`, the result will contain all of the following.
您还可以用标识符标记标签。如果标签是语法中解析器规则或词法符号的名称，则 `getAll()` 的结果列表（或 `get()` 的节点）将包含显式标记为该标签的规则或标签匹配的解析树，以及模式中标记和未标记标签匹配的解析树的完整集合，这些标签对应于该解析器规则或词法符号。例如，如果标签是 `foo`，结果将包含以下所有内容。

* Parse tree nodes matching tags of the form `<foo:anyRuleName>` and `<foo:AnyTokenName>`.
* Parse tree nodes matching tags of the form `<anyLabel:foo>`.
* Parse tree nodes matching tags of the form `<foo>`.
* 匹配形式为 `<foo:anyRuleName>` 和 `<foo:AnyTokenName>` 的标签的解析树节点。
* 匹配形式为 `<anyLabel:foo>` 的标签的解析树节点。
* 匹配形式为 `<foo>` 的标签的解析树节点。

### Creating parse trees with the pattern matcher
### 使用模式匹配器创建解析树

You can use the parse tree pattern compiler to create parse trees for partial input fragments. Just use method `ParseTreePattern.getPatternTree()`.
您可以使用解析树模式编译器为部分输入片段创建解析树。只需使用方法 `ParseTreePattern.getPatternTree()`。

See [TestParseTreeMatch.java](https://github.com/antlr/antlr4/blob/master/tool-testsuite/test/org/antlr/v4/test/tool/TestParseTreeMatcher.java).
参见 [TestParseTreeMatch.java](https://github.com/antlr/antlr4/blob/master/tool-testsuite/test/org/antlr/v4/test/tool/TestParseTreeMatcher.java)。

## Using XPath to identify parse tree node sets
## 使用 XPath 识别解析树节点集

XPath paths are strings representing nodes or subtrees you would like to select within a parse tree. It's useful to collect subsets of the parse tree to process. For example you might want to know where all assignments are in a method or all variable declarations that are initialized.
XPath 路径是表示您希望在解析树中选择的节点或子树的字符串。收集解析树的子集进行处理非常有用。例如，您可能想知道方法中所有赋值语句的位置或所有已初始化的变量声明。

A path is a series of node names with the following separators.
路径是一系列节点名称，使用以下分隔符。

| Expression |Description|
|---------|-----------|
|nodename|	Nodes with the token or rule name nodename
|/|	The root node but `/X` is the same as `X` since the tree you pass to xpath is assumed to be the root. Because it looks better, start all of your patterns with `/` (or `//` below).|
|//|	All nodes in the tree that match the next element in the path. E.g., `//ID` finds all `ID` token nodes in the tree.|
|!|	Any node except for the next element in the path. E.g., `/classdef/!field` should find all children of `classdef` root node that are not `field` subtrees.|
| 表达式 | 描述 |
|---------|-----------|
|nodename|	具有词法符号或规则名称 nodename 的节点
|/|	根节点，但 `/X` 与 `X` 相同，因为传递给 xpath 的树被假定为根节点。为了看起来更好，请使用 `/`（或下面的 `//`）开始所有模式。|
|//|	树中与路径中下一个元素匹配的所有节点。例如，`//ID` 查找树中所有 `ID` 词法符号节点。|
|!|	除路径中下一个元素之外的任何节点。例如，`/classdef/!field` 应查找 `classdef` 根节点中不是 `field` 子树的所有子节点。|

Examples:
示例：

```
/prog/func, -> all funcs under prog at root
/prog/*, -> all children of prog at root
/*/func, -> all func kids of any root node
prog, -> prog must be root node
/prog, -> prog must be root node
/*, -> any root
*, -> any root
//ID, -> any ID in tree
//expr/primary/ID, -> any ID child of a primary under any expr
//body//ID, -> any ID under a body
//'return', -> any 'return' literal in tree
//primary/*, -> all kids of any primary
//func/*/stat, -> all stat nodes grandkids of any func node
/prog/func/'def', -> all def literal kids of func kid of prog
//stat/';', -> all ';' under any stat node
//expr/primary/!ID, -> anything but ID under primary under any expr node
//expr/!primary, -> anything but primary under any expr node
//!*, -> nothing anywhere
/!*, -> nothing at root
```

Given a parse tree, the typical mechanism for visiting those nodes is the following loop:
给定一个解析树，访问这些节点的典型机制是以下循环：

```java
for (ParseTree t : XPath.findAll(tree, xpath, parser) ) {
    ... process t ...
}
```

E.g., here is a general formula for making a list of the text associated with every node identified by a path specification:
例如，以下是为路径规范标识的每个节点关联的文本创建列表的通用公式：

```java
List<String> nodes = new ArrayList<String>();
for (ParseTree t : XPath.findAll(tree, xpath, parser) ) {
    if ( t instanceof RuleContext) {
        RuleContext r = (RuleContext)t;
        nodes.add(parser.getRuleNames()[r.getRuleIndex()]);    }      
    else { 
        TerminalNode token = (TerminalNode)t;
        nodes.add(token.getText());
    }      
}
```

## Combining XPath and tree pattern matching
## 结合 XPath 和树模式匹配

Naturally you can combine the use of XPath to find a set of root nodes and then use tree pattern matching to identify a certain subset of those and extract component nodes.
自然地，您可以结合使用 XPath 来查找一组根节点，然后使用树模式匹配来识别这些节点的特定子集并提取组件节点。

```java
// assume we are parsing Java
ParserRuleContext tree = parser.compilationUnit();
String xpath = "//blockStatement/*"; // get children of blockStatement
String treePattern = "int <Identifier> = <expression>;";
ParseTreePattern p =
    parser.compileParseTreePattern(treePattern,   
        ExprParser.RULE_localVariableDeclarationStatement);
List<ParseTreeMatch> matches = p.findAll(tree, xpath);
System.out.println(matches);
```

See [TestXPath.java](https://github.com/antlr/antlr4/blob/master/tool-testsuite/test/org/antlr/v4/test/tool/TestXPath.java).
参见 [TestXPath.java](https://github.com/antlr/antlr4/blob/master/tool-testsuite/test/org/antlr/v4/test/tool/TestXPath.java)。
