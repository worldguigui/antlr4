# Semantic Predicates
# 语义断言

[原文链接](https://github.com/antlr/antlr4/blob/master/doc/predicates.md)

Semantic predicates, `{...}?`, are boolean expressions written in the target language that indicate the validity of continuing the parse along the path "guarded" by the predicate. Predicates can appear anywhere within a parser rule just like actions can, but only those appearing on the left edge of alternatives can affect prediction (choosing between alternatives).  This section provides all of the fine print regarding the use of semantic predicates in parser and lexer rules. Let's start out by digging deeper into how the parser incorporates predicates into parsing decisions.
语义断言 `{...}?` 是用目标语言编写的布尔表达式，指示沿着该断言"守卫"的路径继续解析的有效性。断言可以像动作一样出现在解析器规则中的任何位置，但只有出现在选项左边缘的断言才能影响预测（在选项之间进行选择）。本节提供了关于在解析器和词法规则中使用语义断言的所有详细说明。让我们首先深入探讨解析器如何将断言纳入解析决策。

## Making Predicated Parsing Decisions
## 进行带断言的解析决策

ANTLR's general decision-making strategy is to find all viable alternatives and then ignore the alternatives guarded with predicates that currently evaluate to false. (A viable alternative is one that matches the current input.) If more than one viable alternative remains, the parser chooses the alternative specified first in the decision.
ANTLR 的一般决策策略是找到所有可行的选项，然后忽略由当前评估为 false 的断言守卫的选项。（可行的选项是匹配当前输入的选项。）如果仍有多个可行选项，解析器将选择决策中首先指定的选项。

Consider a variant of C++ where array references also use parentheses instead of square brackets. If we only predicate one of the alternatives, we still have an ambiguous decision in expr:
考虑一个 C++ 的变体，其中数组引用也使用圆括号而不是方括号。如果我们只对其中一个选项使用断言，expr 中仍然存在歧义决策：

```
expr: ID '(' expr ')' // array reference (ANTLR picks this one)
 	| {istype()}? ID '(' expr ')' // ctor-style typecast
 	| ID '(' expr ')' // function call
 	;
```

In this case, all three alternatives are viable for input `x(i)`. When `x` is not a type name, the predicate evaluates to false, leaving only the first and third alternatives as possible matches for expr. ANTLR automatically chooses the first alternative matching the array reference to resolve the ambiguity. Leaving ANTLR with more than one viable alternative because of too few predicates is probably not a good idea. It's best to cover n viable alternatives with at least n-1 predicates. In other words, don't build rules like expr with too few predicates.
在这种情况下，所有三个选项对于输入 `x(i)` 都是可行的。当 `x` 不是类型名时，断言评估为 false，只留下第一个和第三个选项作为 expr 的可能匹配项。ANTLR 自动选择第一个匹配数组引用的选项来解决歧义。由于断言太少而让 ANTLR 面临多个可行选项可能不是一个好主意。最好用至少 n-1 个断言覆盖 n 个可行选项。换句话说，不要构建像 expr 这样断言太少的规则。

Sometimes, the parser finds multiple visible predicates associated with a single choice. No worries. ANTLR just combines the predicates with appropriate logical operators to conjure up a single meta-predicate on-the-fly.
有时，解析器会发现与单个选择关联的多个可见断言。不用担心。ANTLR 只是将断言与适当的逻辑运算符组合，即时生成一个元断言。

For example, the decision in rule `stat` joins the predicates from both alternatives of expr with the `||` operator to guard the second stat alternative:
例如，规则 `stat` 中的决策将 expr 两个选项的断言与 `||` 运算符连接起来，以守卫第二个 stat 选项：

```
stat: decl | expr ;
decl: ID ID ;
expr: {istype()}? ID '(' expr ')' // ctor-style typecast
 	| {isfunc()}? ID '(' expr ')' // function call
 	;
```

The parser will only predict an expr from stat when `istype()||isfunc()` evaluates to true. This makes sense because the parser should only choose to match an expression if the upcoming `ID` is a type name or function name. It wouldn't make sense to just test one of the predicates in this case. Note that, when the parser gets to `expr` itself, the parsing decision tests the predicates individually, one for each alternative.
只有当 `istype()||isfunc()` 评估为 true 时，解析器才会从 stat 预测 expr。这是有道理的，因为解析器只应在接下来的 `ID` 是类型名或函数名时选择匹配表达式。在这种情况下仅测试其中一个断言是没有意义的。请注意，当解析器到达 `expr` 本身时，解析决策会单独测试每个断言，每个选项一个。

If multiple predicates occur in a sequence, the parser joins them with the `&&` operator. For example, consider changing `stat` to include a predicate before the call `toexpr`:
如果多个断言连续出现，解析器会使用 `&&` 运算符连接它们。例如，考虑更改 `stat` 以在调用 `expr` 之前包含一个断言：

```
stat: decl | {java5}? expr ;
```

Now, the parser would only predict the second alternative if `java5&&(istype()||isfunc())` evaluated to true.
现在，只有当 `java5&&(istype()||isfunc())` 评估为 true 时，解析器才会预测第二个选项。

Turning to the code inside the predicates themselves now, keep in mind the following guidelines.
现在转向断言内部的代码，请记住以下指南。

Even when the parser isn't making decisions, predicates can deactivate alternatives, causing rules to fail. This happens when a rule only has a single alternative. There is no choice to make, but ANTLR evaluates the predicate as part of the normal parsing process, just like it does for actions. That means that the following rule always fails to match.
即使解析器没有进行决策，断言也可以停用选项，导致规则失败。当规则只有一个选项时会发生这种情况。没有选择可做，但 ANTLR 会将断言作为正常解析过程的一部分进行评估，就像它对动作所做的那样。这意味着以下规则总是无法匹配。

```
prog: {false}? 'return' INT ; // throws FailedPredicateException
```

ANTLR converts `{false}?` in the grammar to a conditional in the generated parser:
ANTLR 将语法中的 `{false}?` 转换为生成解析器中的条件语句：

```
if ( !false ) throw new FailedPredicateException(...);
```

So far, all of the predicates we've seen have been visible and available to the prediction process, but that's not always the case.
到目前为止，我们所见的所有断言在预测过程中都是可见且可用的，但情况并非总是如此。

## Finding Visible Predicates
## 查找可见断言

The parser will not evaluate predicates during prediction that occur after an action or token reference. Let's think about the relationship between actions and predicates first.
解析器在预测期间不会评估出现在动作或词法符号引用之后的断言。让我们首先考虑动作和断言之间的关系。

ANTLR has no idea what's inside the raw code of an action and so it must assume any predicate could depend on side effects of that action. Imagine an action that computed value `x` and a predicate that tested `x`. Evaluating that predicate before the action executed to create `x` would violate the implied order of operations within the grammar.
ANTLR 不知道动作的原始代码内部是什么，因此它必须假设任何断言都可能依赖于该动作的副作用。想象一个计算值 `x` 的动作和一个测试 `x` 的断言。在动作执行创建 `x` 之前评估该断言将违反语法中隐含的操作顺序。

More importantly, the parser can't execute actions until it has decided which alternative to match. That's because actions have side effects and we can't undo things like print statements. For example, in the following rule, the parser can't execute the action in front of the `{java5}?` predicate before committing to that alternative.
更重要的是，解析器在决定匹配哪个选项之前无法执行动作。这是因为动作有副作用，我们无法撤销诸如打印语句之类的事情。例如，在以下规则中，解析器在确定该选项之前无法执行 `{java5}?` 断言前的动作。

```
@members {boolean allowgoto=false;}
stat: {System.out.println("goto"); allowgoto=true;} {java5}? 'goto' ID ';'
 	| ...
 	;
```

If we can't execute the action during prediction, we shouldn't evaluate the `{java5}?` predicate because it depends on that action.
如果我们不能在预测期间执行动作，我们就不应该评估 `{java5}?` 断言，因为它依赖于该动作。

The prediction process also can't see through token references. Token references have the side effect of advancing the input one symbol. A predicate that tested the current input symbol would find itself out of sync if the parser shifted it over the token reference. For example, in the following grammar, the predicates expect `getCurrentToken` to return an `ID` token.
预测过程也无法"看穿"词法符号引用。词法符号引用有前进输入一个符号的副作用。如果解析器将其移过词法符号引用，测试当前输入符号的断言将会发现自身不同步。例如，在以下语法中，断言期望 `getCurrentToken` 返回一个 `ID` 词法符号。

```
stat: '{' decl '}'
 	| '{' stat '}'
 	;
decl: {istype(getCurrentToken().getText())}? ID ID ';' ;
expr: {isvar(getCurrentToken().getText())}? ID ;
```

The decision in stat can't test those predicates because, at the start of stat, the current token is a left curly. To preserve the semantics, ANTLR won't test the predicates in that decision.
stat 中的决策无法测试这些断言，因为在 stat 开始时，当前词法符号是左花括号。为了保留语义，ANTLR 不会测试该决策中的断言。

Visible predicates are those that prediction encounters before encountering an action or token. The prediction process ignores nonvisible predicates, treating them as if they don't exist.
可见断言是预测在遇到动作或词法符号之前遇到的断言。预测过程会忽略不可见断言，将其视为不存在。

In rare cases, the parser won't be able to use a predicate, even if it's visible to a particular decision. That brings us to our next fine print topic.
在极少数情况下，即使断言对特定决策可见，解析器也无法使用它。这引出了我们下一个详细说明的主题。

## Using Context-Dependent Predicates
## 使用上下文相关断言

A predicate that depends on a parameter or local variable of the surrounding rule, is considered a context-dependent predicate. Clearly, we can only evaluate such predicates within the rules in which they're defined. For example, it makes no sense for the decision in prog below to test context-dependent predicate `{$i<=5}?`. That `$i` local variable is not even defined in `prog`.
依赖于周围规则的参数或局部变量的断言被视为上下文相关断言。显然，我们只能在定义它们的规则内评估此类断言。例如，下面的 prog 中的决策测试上下文相关断言 `{$i<=5}?` 是没有意义的。该 `$i` 局部变量甚至在 `prog` 中都没有定义。

```
prog: vec5
 	| ...
 	;
vec5
locals [int i=1]
 	: ( {$i<=5}? INT {$i++;} )* // match 5 INTs
 	;
```

ANTLR ignores context-dependent predicates that it can't evaluate in the proper context. Normally the proper context is simply the rule defining the predicate, but sometimes the parser can't even evaluate a context-dependent predicate from within the same rule! Detecting these cases is done on-the-fly at runtime during adaptive LL(*) prediction.
ANTLR 会忽略在适当上下文中无法评估的上下文相关断言。通常适当的上下文就是定义该断言的规则，但有时解析器甚至无法从同一规则内评估上下文相关断言！这些情况的检测是在自适应 LL(*) 预测期间运行时即时完成的。

For example, prediction for the optional branch of the else subrule in stat below "falls off" the end of stat and continues looking for symbols in the invoking prog rule.
例如，下面 stat 中 else 子规则的可选分支的预测会"超出" stat 的末尾，并继续在调用的 prog 规则中查找符号。

```
prog: stat+ ; // stat can follow stat
stat
locals [int i=0]
 	: {$i==0}? 'if' expr 'then' stat {$i=5;} ('else' stat)?
 	| 'break' ';'
 	;
```

The prediction process is trying to figure out what can follow an if statement other than an else clause. Since the input can have multiple stats in a row, the prediction for the optional branch of the else subrule reenters stat. This time, of course, it gets a new copy of `$i` with a value of 0, not 5. ANTLR ignores context-dependent predicate `{$i==0}?` because it knows that the parser isn't in the original stat call. The predicate would test a different version of `$i` so the parser can't evaluate it.
预测过程试图找出 if 语句后面可以跟什么（除了 else 子句）。由于输入可以连续有多个 stat，对 else 子规则可选分支的预测会重新进入 stat。当然，这次它获得的是值为 0 的 `$i` 的新副本，而不是 5。ANTLR 忽略上下文相关断言 `{$i==0}?`，因为它知道解析器不在原始的 stat 调用中。该断言将测试不同版本的 `$i`，因此解析器无法评估它。

The fine print for predicates in the lexer more or less follow these same guidelines, except of course lexer rules can't have parameters and local variables. Let's look at all of the lexer-specific guidelines in the next section.
词法分析器中断言的详细说明或多或少遵循这些相同的准则，当然除了词法规则不能有参数和局部变量。让我们在下一节中查看所有特定于词法分析器的准则。

## Predicates in Lexer Rules
## 词法规则中的断言

In parser rules, predicates must appear on the left edge of alternatives to aid in alternative prediction. Lexers, on the other hand, prefer predicates on the right edge of lexer rules because they choose rules after seeing a token's entire text. Predicates in lexer rules can technically be anywhere within the rule. Some positions might be more or less efficient than others; ANTLR makes no guarantees about the optimal spot. A predicate in a lexer rule might be executed multiple times even during a single token match. You can embed multiple predicates per lexer rule and they are evaluated as the lexer reaches them during matching.
在解析器规则中，断言必须出现在选项的左边缘以辅助选项预测。另一方面，词法分析器更喜欢词法规则右边缘的断言，因为它们在看到词法符号的整个文本后选择规则。从技术上讲，词法规则中的断言可以位于规则内的任何位置。某些位置可能比其他位置效率更高或更低；ANTLR 不保证最佳位置。词法规则中的断言即使在单个词法符号匹配期间也可能被执行多次。您可以在每个词法规则中嵌入多个断言，它们会在词法分析器在匹配过程中到达它们时被评估。

Loosely speaking, the lexer's goal is to choose the rule that matches the most input characters. At each character, the lexer decides which rules are still viable. Eventually, only a single rule will be still viable. At that point, the lexer creates a token object according the rule's token type and matched text.
粗略地说，词法分析器的目标是选择匹配最多输入字符的规则。在每个字符处，词法分析器决定哪些规则仍然可行。最终，只有一个规则仍然可行。此时，词法分析器根据规则的词法符号类型和匹配的文本创建词法符号对象。

Sometimes the lexer is faced with more than a single viable matching rule. For example, input enum would match an `ENUM` rule and an `ID` rule. If the next character after enum is a space, neither rule can continue. The lexer resolves the ambiguity by choosing the viable rule specified first in the grammar. That's why we have to place keyword rules before an identifier rule like this:
有时词法分析器会面临多个可行的匹配规则。例如，输入 enum 将匹配 `ENUM` 规则和 `ID` 规则。如果 enum 后面的下一个字符是空格，则两个规则都无法继续。词法分析器通过选择语法中首先指定的可行规则来解决歧义。这就是为什么我们必须将关键字规则放在标识符规则之前，像这样：

```
ENUM : 'enum' ;
ID : [a-z]+ ;
```

If, on the other hand, the next character after input `enum` is a letter, then only `ID` is viable.
另一方面，如果输入 `enum` 后面的下一个字符是字母，则只有 `ID` 是可行的。

Predicates come into play by pruning the set of viable lexer rules. When the lexer encounters a false predicate, it deactivates that rule just like parsers deactivate alternatives with false predicates.
断言通过修剪可行的词法规则集来发挥作用。当词法分析器遇到 false 断言时，它会停用该规则，就像解析器停用带有 false 断言的选项一样。

Like parser predicates, lexer predicates can't depend on side effects from lexer actions. That said, the predicate can depend on a side effect of an action that occured during the recognition of the previous token. That's because actions can only execute after the lexer positively identifies the rule to match. Since predicates are part of the rule selection process, they can't rely on action side effects created by actions in currently-prospective rules. Lexer actions must appear after predicates in lexer rules. As an example, here's another way to match enum as a keyword in the lexer:
与解析器断言一样，词法分析器断言不能依赖于词法分析器动作的副作用。也就是说，断言可以依赖于识别前一个词法符号期间发生的动作的副作用。这是因为动作只能在词法分析器明确识别要匹配的规则之后执行。由于断言是规则选择过程的一部分，它们不能依赖于当前候选规则中动作创建的副作用。词法动作必须出现在词法规则中的断言之后。例如，这是在词法分析器中匹配 enum 作为关键字的另一种方法：

```
ENUM: [a-z]+ {getText().equals("enum")}?
	   {System.out.println("enum!");}
    ;
ID  : [a-z]+ {System.out.println("ID "+getText());} ;
```

The print action in `ENUM` appears last and executes only if the current input matches `[a-z]+` and the predicate is true. Let's build and test `Enum3` to see if it distinguishes between enum and an identifier:
`ENUM` 中的打印动作出现在最后，并且仅当当前输入匹配 `[a-z]+` 且断言为 true 时执行。让我们构建并测试 `Enum3`，看看它是否能区分 enum 和标识符：

```bash
$ antlr4 Enum3.g4
$ javac Enum3.java
$ grun Enum3 tokens
=> 	enum abc
=> 	EOF
<= 	enum!
 	ID abc
```

That works great, but it's really just for instructional purposes. It's easier to understand and more efficient to match enum keywords with a simple rule like this:
这工作得很好，但这真的只是为了教学目的。使用这样的简单规则来匹配 enum 关键字更容易理解且更高效：

```
ENUM : 'enum' ;
```

Here's another example of a predicate.  It's important to note that the predicate is evaluated before the action because actions are only executed if the lexer rule matches. The actions are not executed in line; they are collected and executed en mass later.
这是另一个断言的例子。需要注意的是，断言在动作之前评估，因为动作仅在词法规则匹配时执行。动作不是内联执行的；它们被收集起来，稍后批量执行。

```
INDENT : [ \t]+ {System.out.println("INDENT")>} {this.getCharPositionInLine()==0}? ;
```

For more information on how actions and predicates operate in the lexer, see [Lexer actions and semantic predicates are executed out of order](https://github.com/antlr/antlr4/issues/3611) and [Lexer.getCharIndex() return value not behaving as expected](https://github.com/antlr/antlr4/issues/3606). The lexer rule that will not work as expected is:
有关动作和断言如何在词法分析器中操作的更多信息，请参阅 [词法分析器动作和语义断言执行顺序错乱](https://github.com/antlr/antlr4/issues/3611) 和 [Lexer.getCharIndex() 返回值未按预期行为](https://github.com/antlr/antlr4/issues/3606)。不会按预期工作的词法规则是：

```
Stuff : ( 'a'+ {count++;} | 'b') 'c' 'd' {count == 3}? ;
```

The `count++` code we'll not execute until after `Stuff` has been recognized (assuming count!=3).
`count++` 代码直到 `Stuff` 被识别之后才会执行（假设 count!=3）。
