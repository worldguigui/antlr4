# Options
# 选项

[原文链接](https://github.com/antlr/antlr4/blob/master/doc/options.md)

There are a number of options that you can specify at the grammar and rule element level. (There are currently no rule options.) These change how ANTLR generates code from your grammar. The general syntax is:
您可以在语法和规则元素级别指定许多选项。（目前没有规则选项。）这些选项会改变 ANTLR 从您的语法生成代码的方式。通用语法是：

```
options { name1=value1; ... nameN=valueN; } // ANTLR not target language syntax
```

where a value can be an identifier, a qualified identifier (for example, a.b.c), a string, a multi-line string in curly braces `{...}`, and an integer.
其中值可以是标识符、限定标识符（例如 a.b.c）、字符串、花括号中的多行字符串 `{...}` 和整数。

## Grammar Options
## 语法选项

All grammars can use the following options. In combined grammars, all options except language pertain only to the generated parser. Options may be set either within the grammar file using the options syntax (described above) or when invoking ANTLR on the command line, using the `-D` option. (see Section 15.9, [ANTLR Tool Command Line Options](tool-options.md).) The following examples demonstrate both mechanisms; note that `-D` overrides options within the grammar.
所有语法都可以使用以下选项。在组合语法中，除 language 外的所有选项仅适用于生成的解析器。选项可以在语法文件中使用选项语法（如上所述）设置，也可以在命令行调用 ANTLR 时使用 `-D` 选项设置。（参见第 15.9 节 [ANTLR 工具命令行选项](tool-options.md)。）以下示例演示了两种机制；请注意 `-D` 会覆盖语法内的选项。

### `superClass`
### `superClass` 选项

Set the superclass of the generated parser or lexer. For combined grammars, it sets the superclass of the parser.
设置生成的解析器或词法分析器的超类。对于组合语法，它设置解析器的超类。

```
$ cat Hi.g4
grammar Hi;
a : 'hi' ;
$ antlr4 -DsuperClass=XX Hi.g4
$ grep 'public class' HiParser.java
public class HiParser extends XX {
$ grep 'public class' HiLexer.java
public class HiLexer extends Lexer {
```

### `language`
### `language` 选项

Generate code in the indicated language, if ANTLR is able to do so. Otherwise, you will see an error message like this:
如果 ANTLR 能够做到，则以指定语言生成代码。否则，您将看到类似以下的错误消息：

```
$ antlr4 -Dlanguage=C MyGrammar.g4
error(31):  ANTLR cannot generate C code as of version 4.0
```

### `tokenVocab`
### `tokenVocab` 选项

ANTLR assigns token type numbers to the tokens as it encounters them in a file. To use different token type values, such as with a separate lexer, use this option to have ANTLR pull in the <fileextension>tokens</fileextension> file. ANTLR generates a <fileextension>tokens</fileextension> file from each grammar.
ANTLR 在文件中遇到词法符号时会为其分配词法符号类型编号。要使用不同的词法符号类型值，例如使用独立的词法分析器，请使用此选项让 ANTLR 引入 <fileextension>tokens</fileextension> 文件。ANTLR 从每个语法生成一个 <fileextension>tokens</fileextension> 文件。

```
$ cat SomeLexer.g4
lexer grammar SomeLexer;
ID : [a-z]+ ;
$ cat R.g4
parser grammar R;
options {tokenVocab=SomeLexer;}
tokens {A,B,C} // normally, these would be token types 1, 2, 3
a : ID ;
$ antlr4 SomeLexer.g4
$ cat SomeLexer.tokens 
ID=1
$ antlr4 R.g4
$ cat R.tokens
A=2
B=3
C=4
ID=1
```

### `TokenLabelType`
### `TokenLabelType` 选项

ANTLR normally uses type <class>Token</class> when it generates variables referencing tokens. If you have passed a <class>TokenFactory</class> to your parser and lexer so that they create custom tokens, you should set this option to your specific type. This ensures that the context objects know your type for fields and method return values.
ANTLR 在生成引用词法符号的变量时通常使用 <class>Token</class> 类型。如果您已将 <class>TokenFactory</class> 传递给解析器和词法分析器以便它们创建自定义词法符号，则应将此选项设置为您的特定类型。这确保上下文对象了解您的字段和方法返回值的类型。

```
$ cat T2.g4
grammar T2;
options {TokenLabelType=MyToken;}
a : x=ID ;
$ antlr4 T2.g4
$ grep MyToken T2Parser.java
    public MyToken x;
```

### `contextSuperClass`
### `contextSuperClass` 选项

Specify the super class of parse tree internal nodes. Default is `ParserRuleContext`. Should derive from ultimately `RuleContext` at minimum.
指定解析树内部节点的超类。默认为 `ParserRuleContext`。应至少最终派生自 `RuleContext`。
Java target can use `contextSuperClass=org.antlr.v4.runtime.RuleContextWithAltNum` for convenience. It adds a backing field for `altNumber`, the alt matched for the associated rule node.
Java 目标可以使用 `contextSuperClass=org.antlr.v4.runtime.RuleContextWithAltNum` 以方便使用。它为 `altNumber` 添加了一个后备字段，即与关联规则节点匹配的 alt。

### `caseInsensitive`
### `caseInsensitive` 选项

As of 4.10, ANTLR supports case-insensitive lexers using a grammar option. For example, the parser from the following grammar:
从 4.10 版本开始，ANTLR 支持使用语法选项的不区分大小写的词法分析器。例如，以下语法生成的解析器：

```g4
lexer grammar L;
options { caseInsensitive = true; }
ENGLISH_TOKEN:   [a-z]+;
GERMAN_TOKEN:    [äéöüß]+;
FRENCH_TOKEN:    [àâæ-ëîïôœùûüÿ]+;
CROATIAN_TOKEN:  [ćčđšž]+;
ITALIAN_TOKEN:   [àèéìòù]+;
SPANISH_TOKEN:   [áéíñóúü¡¿]+;
GREEK_TOKEN:     [α-ω]+;
RUSSIAN_TOKEN:   [а-я]+;
WS:              [ ]+ -> skip;
```

matches words such as the following:
匹配以下单词：

```
abcXYZ äéöüßÄÉÖÜß àâæçÙÛÜŸ ćčđĐŠŽ àèéÌÒÙ áéÚÜ¡¿ αβγΧΨΩ абвЭЮЯ
```

ANTLR considers only one-length chars in all cases. For instance, german lower `ß` is not treated as upper `ss` and vice versa.
ANTLR 在所有情况下只考虑单字符。例如，德语小写 `ß` 不被视为大写 `ss`，反之亦然。

The mechanism works by automatically transforming grammar references to characters to there upper/lower case equivalent; e.g., `a` to `[aA]`. This means that you do not need to convert your input characters to uppercase--token text will be as it appears in the input stream.
该机制通过自动将语法中的字符引用转换为其大写/小写等价物来工作；例如，`a` 转换为 `[aA]`。这意味着您不需要将输入字符转换为大写——词法符号文本将保持其在输入流中出现的样子。

## Rule Options
## 规则选项

### caseInsensitive
### caseInsensitive 选项

The tool support `caseInsensitive` lexer rule option that is described in [lexer-rules.md](lexer-rules.md#caseinsensitive).
工具支持在 [lexer-rules.md](lexer-rules.md#caseinsensitive) 中描述的 `caseInsensitive` 词法规则选项。

## Rule Element Options
## 规则元素选项

Token options have the form `T<name=value>` as we saw in Section 5.4, [Dealing with Precedence, Left Recursion, and Associativity](http://pragprog.com/book/tpantlr2/the-definitive-antlr-4-reference). The only token option is `assoc`, and it accepts values `left` and `right`. Here’s a sample grammar with a left-recursive expression rule that specifies a token option on the `^` exponent operator token:
词法符号选项的形式为 `T<name=value>`，正如我们在第 5.4 节[处理优先级、左递归和结合性](http://pragprog.com/book/tpantlr2/the-definitive-antlr-4-reference)中看到的。唯一的词法符号选项是 `assoc`，它接受值 `left` 和 `right`。以下是一个示例语法，其中包含一个左递归表达式规则，该规则在 `^` 指数运算符词法符号上指定了一个选项：

```
grammar ExprLR;
 	 
expr : expr '^'<assoc=right> expr
 	| expr '*' expr // match subexpressions joined with '*' operator
 	| expr '+' expr // match subexpressions joined with '+' operator
 	| INT // matches simple integer atom
 	;
 	 
INT : '0'..'9'+ ;
WS : [ \n]+ -> skip ;
```

Semantic predicates also accept an option, per [Catching failed semantic predicates](http://pragprog.com/book/tpantlr2/the-definitive-antlr-4-reference). The only valid option is the `fail` option, which takes either a string literal in double-quotes or an action that evaluates to a string. The string literal or string result from the action should be the message to emit upon predicate failure.
根据[捕获失败的语义断言](http://pragprog.com/book/tpantlr2/the-definitive-antlr-4-reference)，语义断言也接受一个选项。唯一有效的选项是 `fail` 选项，它接受双引号中的字符串字面量或计算结果为字符串的动作。该字符串字面量或动作产生的字符串结果应作为断言失败时发出的消息。

```
ints[int max]
 	locals [int i=1]
 	: INT ( ',' {$i++;} {$i<=$max}?<fail={"exceeded max "+$max}> INT )*
 	;
```

The action can execute a function as well as compute a string when a predicate fails: `{...}?<fail={doSomethingAndReturnAString()}>`
当断言失败时，该动作可以执行函数并计算字符串：`{...}?<fail={doSomethingAndReturnAString()}>`
