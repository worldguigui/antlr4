# ANTLR Tool Command Line Options
# ANTLR 工具命令行选项

[原文链接](https://github.com/antlr/antlr4/blob/master/doc/tool-options.md)

If you invoke the ANTLR tool without command line arguments, you’ll get a help message:
如果您不带命令行参数调用 ANTLR 工具，您将获得帮助信息：

```bash
$ antlr4
ANTLR Parser Generator  Version 4.7.1
 -o ___              specify output directory where all output is generated
 -lib ___            specify location of grammars, tokens files
 -atn                generate rule augmented transition network diagrams
 -encoding ___       specify grammar file encoding; e.g., euc-jp
 -message-format ___ specify output style for messages in antlr, gnu, vs2005
 -long-messages      show exception details when available for errors and warnings
 -listener           generate parse tree listener (default)
 -no-listener        don't generate parse tree listener
 -visitor            generate parse tree visitor
 -no-visitor         don't generate parse tree visitor (default)
 -package ___        specify a package/namespace for the generated code
 -depend             generate file dependencies
 -D<option>=value    set/override a grammar-level option
 -Werror             treat warnings as errors
 -XdbgST             launch StringTemplate visualizer on generated code
 -XdbgSTWait         wait for STViz to close before continuing
 -Xforce-atn         use the ATN simulator for all predictions
 -Xlog               dump lots of logging info to antlr-timestamp.log
 -Xexact-output-dir  all output goes into -o dir regardless of paths/package
```

Here are more details on the options:
以下是关于这些选项的更多详细信息：

## `-o outdir`
## `-o 输出目录`

ANTLR generates output files in the current directory by default. This option specifies the output directory where ANTLR should generate parsers, listeners, visitors, and tokens files.
ANTLR 默认在当前目录中生成输出文件。此选项指定 ANTLR 应生成解析器、监听器、访问者和词法符号文件的输出目录。

```bash
$ antlr4 -o /tmp T.g4
$ ls /tmp/T*
/tmp/T.tokens /tmp/TListener.java
/tmp/TBaseListener.java /tmp/TParser.java
```

## `-lib libdir`
## `-lib 库目录`

When looking for tokens files and imported grammars, ANTLR normally looks in the current directory. This option specifies which directory to look in instead. It is only used for resolving grammar references for the import statement and the tokenVocab option. The path to the primary grammar must always be fully specified.
在查找词法符号文件和导入的语法时，ANTLR 通常在当前目录中查找。此选项指定要查找的目录。它仅用于解析 import 语句和 tokenVocab 选项的语法引用。主语法的路径必须始终完全指定。

$ cat /tmp/B.g4
 	
parser grammar B;
 	
x : ID ;
 	
$ cat A.g4
 	
grammar A;
 	
import B;
 	
s : x ;
 	
ID : [a-z]+ ;
 	
$ antlr4 -lib /tmp A.g4

## `-atn`
## `-atn` 选项

Generate DOT graph files that represent the internal ATN (augmented transition network) data structures that ANTLR uses to represent grammars. The files come out as Grammar.rule .dot. If the grammar is a combined grammar, the lexer rules are named Grammar Lexer.rule .dot.
生成表示 ANTLR 用于表示语法的内部 ATN（增强转换网络）数据结构的 DOT 图形文件。文件输出为 Grammar.rule.dot。如果语法是组合语法，则词法规则命名为 GrammarLexer.rule.dot。

$ cat A.g4
 	
grammar A;
 	
s : b ;
 	
b : ID ;
 	
ID : [a-z]+ ;
 	
$ antlr4 -atn A.g4
 	
$ ls *.dot
 	
A.b.dot A.s.dot ALexer.ID.dot

## `-encoding encodingname`
## `-encoding 编码名称`

By default ANTLR loads grammar files using the UTF-8 encoding, which is a very common character file encoding that degenerates to ASCII for characters that fit in one byte. There are many character file encodings from around the world. If that grammar file is not the default encoding for your locale, you need this option so that ANTLR can properly interpret grammar files. This does not affect the input to the generated parsers, just the encoding of the grammars themselves.
默认情况下，ANTLR 使用 UTF-8 编码加载语法文件，这是一种非常常见的字符文件编码，对于适合一个字节的字符会退化为 ASCII。世界各地有许多字符文件编码。如果该语法文件不是您区域的默认编码，则需要此选项以便 ANTLR 能够正确解释语法文件。这不会影响生成解析器的输入，仅影响语法本身的编码。

## `-message-format format`
## `-message-format 格式`

ANTLR generates warning and error messages using templates from directory tool/resources/org/antlr/v4/tool/templates/messages/formats. By default, ANTLR uses the antlr.stg (StringTemplate group) file. You can change this to gnu or vs2005 to have ANTLR generate messages appropriate for Emacs or Visual Studio. To make your own called X, create resource org/antlr/v4/tool/templates/messages/formats/ X and place it in the CLASSPATH.
ANTLR 使用目录 tool/resources/org/antlr/v4/tool/templates/messages/formats 中的模板生成警告和错误消息。默认情况下，ANTLR 使用 antlr.stg（StringTemplate 组）文件。您可以将其更改为 gnu 或 vs2005，以使 ANTLR 生成适用于 Emacs 或 Visual Studio 的消息。要创建自己的名为 X 的格式，请创建资源 org/antlr/v4/tool/templates/messages/formats/X 并将其放入 CLASSPATH 中。

## `-listener`
## `-listener` 选项

This option tells ANTLR to generate a parse tree listener and is the default.
此选项告诉 ANTLR 生成解析树监听器，这是默认设置。

## `-no-listener`
## `-no-listener` 选项

This option tells ANTLR not to generate a parse tree listener.
此选项告诉 ANTLR 不生成解析树监听器。

## `-visitor`
## `-visitor` 选项

ANTLR does not generate parse tree visitors by default. This option turns that feature on. ANTLR can generate both parse tree listeners and visitors; this option and -listener aren’t mutually exclusive.
ANTLR 默认不生成解析树访问者。此选项开启该功能。ANTLR 可以同时生成解析树监听器和访问者；此选项和 -listener 并不互斥。

## `-no-visitor`
## `-no-visitor` 选项

Tell ANTLR not to generate a parse tree visitor; this is the default.
告诉 ANTLR 不生成解析树访问者；这是默认设置。

## `-package`
## `-package` 选项

Use this option to specify a package or namespace for ANTLR-generated files. Alternatively, you can add a @header {...} action but that ties the grammar to a specific language. If you use this option and @header, make sure that the header action does not contain a package specification otherwise the generated code will have two of them.
使用此选项为 ANTLR 生成的文件指定包或命名空间。或者，您可以添加 @header {...} 动作，但这会将语法绑定到特定语言。如果您使用此选项和 @header，请确保头动作不包含包规范，否则生成的代码将有两个包规范。

## `-depend`
## `-depend` 选项

Instead of generating a parser and/or lexer, generate a list of file dependencies, one per line. The output shows what each grammar depends on and what it generates. This is useful for build tools that need to know ANTLR grammar dependencies. Here’s an example:
不生成解析器和/或词法分析器，而是生成文件依赖项列表，每行一个。输出显示每个语法依赖什么以及生成什么。这对于需要了解 ANTLR 语法依赖项的构建工具非常有用。以下是一个示例：

```bash
$ antlr4 -depend T.g	
T.g: A.tokens
TParser.java : T.g
T.tokens : T.g
TLexer.java : T.g
TListener.java : T.g
TBaseListener.java : T.g
```

If you use -lib libdir with -depend and grammar option tokenVocab=A, then the dependencies include the library path as well: T.g: libdir/A.tokens. The output is also sensitive to the -o outdir option: outdir/TParser.java : T.g.
如果您将 -lib libdir 与 -depend 和语法选项 tokenVocab=A 一起使用，则依赖项还包括库路径：T.g: libdir/A.tokens。输出也对 -o outdir 选项敏感：outdir/TParser.java : T.g。

## `-D<option>=value`
## `-D<选项>=值` 选项

Use this option to override or set a grammar-level option in the specified grammar or grammars. This option is useful for generating parsers in different languages without altering the grammar itself. (I expect to have other targets in the near future.)
使用此选项在指定的一个或多个语法中覆盖或设置语法级选项。此选项对于生成不同语言的解析器非常有用，而无需更改语法本身。（我期望在不久的将来有其他目标。）

```bash
$ antlr4 -Dlanguage=Java T.g4 # default
$ antlr4 -Dlanguage=C T.g4
error(31): ANTLR cannot generate C code as of version 4.0b3
```

## `-Werror`
## `-Werror` 选项

As part of a large build, ANTLR warning messages could go unnoticed. Turn on this option to have warnings treated as errors, causing the ANTLR tool to report failure back to the invoking commandline shell.
作为大型构建的一部分，ANTLR 警告消息可能会被忽略。打开此选项可将警告视为错误，导致 ANTLR 工具向调用命令行 shell 报告失败。
There are also some extended options that are useful mainly for debugging ANTLR itself:
还有一些主要对调试 ANTLR 本身有用的扩展选项：

## `-Xsave-lexer`
## `-Xsave-lexer` 选项

ANTLR generates both a parser and a lexer from a combined grammar. To create the lexer, ANTLR extracts a lexer grammar from the combined grammar. Sometimes it’s useful to see what that looks like if it’s not clear what token rules ANTLR is creating. This does not affect the generated parsers or lexers.
ANTLR 从组合语法生成解析器和词法分析器。为了创建词法分析器，ANTLR 从组合语法中提取词法语法。如果不清楚 ANTLR 正在创建什么词法规则，有时查看其外观很有用。这不会影响生成的解析器或词法分析器。

## `-XdbgST`
## `-XdbgST` 选项

For those building a code generation target, this option brings up a window showing the generated code and the templates used to generate that code. It invokes the StringTemplate inspector window.
对于构建代码生成目标的人员，此选项会打开一个窗口，显示生成的代码以及用于生成该代码的模板。它会调用 StringTemplate 检查器窗口。

## `-Xforce-atn`
## `-Xforce-atn` 选项

ANTLR normally builds traditional “switch on token type” decisions where possible (one token of lookahead is sufficient to distinguish between all alternatives in a decision). To force even these simple decisions into the adaptive LL(*) mechanism, use this option.
ANTLR 通常在可能的情况下构建传统的"基于词法符号类型切换"的决策（一个前瞻词法符号足以区分决策中的所有备选项）。要强制甚至这些简单决策也使用自适应 LL(*) 机制，请使用此选项。

## `-Xlog`
## `-Xlog` 选项

This option creates a log file containing lots of information messages from ANTLR as it processes your grammar. If you would like to see how ANTLR translates your left-recursive rules, turn on this option and look in the resulting log file.
此选项创建一个日志文件，其中包含 ANTLR 处理语法时的大量信息消息。如果您想了解 ANTLR 如何转换您的左递归规则，请打开此选项并查看生成的日志文件。

```bash
$ antlr4 -Xlog T.g4 	
wrote ./antlr-2012-09-06-17.56.19.log
```

## `-Xexact-output-dir`
## `-Xexact-output-dir` 选项

(*See the [discussion](https://github.com/antlr/antlr4/pull/2065)*).
（*参见[讨论](https://github.com/antlr/antlr4/pull/2065)*）。

All output goes into `-o` dir regardless of paths/package.
所有输出都进入 `-o` 目录，无论路径/包如何。

* Output `-o` directory specifier is the exact directory containing the output. Previously it would include the relative path specified on the grammar itself for the purposes of packages.
* 输出 `-o` 目录说明符是包含输出的确切目录。以前它会包括语法本身上为包目的指定的相对路径。

**new**: `-o /tmp subdir/T.g4` => `/tmp/subdir/T.java`
**old**: `-o /tmp subdir/T.g4` => `/tmp/T.java`
**新**：`-o /tmp subdir/T.g4` => `/tmp/subdir/T.java`
**旧**：`-o /tmp subdir/T.g4` => `/tmp/T.java`

*  Previously we looked for the tokens vocab file in the `-lib` dir or in the output dir. **New**: also look in the directory containing the grammar, particularly if it it is specified with a path.
*  以前我们在 `-lib` 目录或输出目录中查找词法符号词汇表文件。**新**：也在包含语法的目录中查找，特别是如果它是用路径指定的。

### Example for the output directory (4.7)
### 输出目录示例 (4.7)

Here is the existing 4.7 functionality.
以下是现有的 4.7 功能。

(For these examples, assume a4.7 and a4.7.1 are aliases to the right version of ANTLR's `org.antlr.v4.Tool`.)
（对于这些示例，假设 a4.7 和 a4.7.1 是正确版本的 ANTLR `org.antlr.v4.Tool` 的别名。）

```bash
$ cd /tmp/parrt
$ tree
.
├── B.g4
└── src
    └── pkg
        └── A.g4
$ a4.7 -o /tmp/build src/pkg/A.g4
$ tree /tmp/build
/tmp/build/
└── src
    └── pkg
        ├── A.tokens
        ├── ABaseListener.java
        ├── ALexer.java
        ├── ALexer.tokens
        ├── AListener.java
        └── AParser.java
```

Now, let's build a grammar that sits in the current directory:
现在，让我们构建一个位于当前目录中的语法：

```bash
$ a4.7 -o /tmp/build B.g4
$ tree /tmp/build
/tmp/build
├── B.tokens
├── BBaseListener.java
├── BLexer.java
├── BLexer.tokens
├── BListener.java
├── BParser.java
└── src
    └── pkg
        ├── A.tokens
        ├── ABaseListener.java
        ├── ALexer.java
        ├── ALexer.tokens
        ├── AListener.java
        └── AParser.java
```

Finally, if we don't specify the output directory, it paid attention to the relative path specified on the input grammar:
最后，如果我们不指定输出目录，它会关注输入语法上指定的相对路径：

```bash
$ a4.7 src/pkg/A.g4
$ tree
.
├── B.g4
└── src
    └── pkg
        ├── A.g4
        ├── A.tokens
        ├── ABaseListener.java
        ├── ALexer.java
        ├── ALexer.tokens
        ├── AListener.java
        └── AParser.java
```

### Example for the output directory (4.7.1 with -Xexact-output-dir)
### 输出目录示例 (4.7.1 带 -Xexact-output-dir)

Now, the output directory is the exact directory where output is generated regardless of relative paths on the grammar
现在，输出目录是生成输出的确切目录，无论语法上的相对路径如何

```bash
$ cd /tmp/parrt
$ a4.7.1 -Xexact-output-dir  -o /tmp/build src/pkg/A.g4
$ tree /tmp/build
/tmp/build
├── A.tokens
├── ABaseListener.java
├── ALexer.java
├── ALexer.tokens
├── AListener.java
└── AParser.java
```

If you use the package option, it still does not change where the output is generated if you use `-o`
如果您使用包选项，它仍然不会更改使用 `-o` 时的输出位置

```bash
$ a4.7.1 -Xexact-output-dir -package pkg -o /tmp/build src/pkg/A.g4
$ tree /tmp/build
/tmp/build
├── A.tokens
├── ABaseListener.java
├── ALexer.java
├── ALexer.tokens
├── AListener.java
└── AParser.java
```

4.7.1 does however add the package specification into the generated files:
然而，4.7.1 确实将包规范添加到生成的文件中：

```bash
$ grep package /tmp/build/A*.java
/tmp/build/ABaseListener.java:package pkg;
/tmp/build/ALexer.java:package pkg;
/tmp/build/AListener.java:package pkg;
/tmp/build/AParser.java:package pkg;
```

Compare this to 4.7:
与 4.7 比较：

```bash
$ a4.7 -package pkg -o /tmp/build src/pkg/A.g4
beast:/tmp/parrt $ tree /tmp/build
/tmp/build
└── src
    └── pkg
        ├── A.tokens
        ├── ABaseListener.java
        ├── ALexer.java
        ├── ALexer.tokens
        ├── AListener.java
        └── AParser.java
```

### Example of where it looks for tokens vocab
### 查找词法符号词汇表示例

In 4.7, we got an error for an obvious case that should work:
在 4.7 中，我们遇到了一个明显应该工作的情况的错误：

```bash
$ cd /tmp/parrt
$ tree
.
└── src
    └── pkg
        ├── L.g4
        └── P.g4
$ a4.7 -o /tmp/build src/pkg/*.g4
error(160): P.g4:2:21: cannot find tokens file /tmp/build/L.tokens
warning(125): P.g4:3:4: implicit definition of token A in parser
```

In 4.7.1 it looks in the directory containing the grammars as well:
在 4.7.1 中，它也会在包含语法的目录中查找：

```bash
$ a4.7.1 -o /tmp/build src/pkg/*.g4
$ tree /tmp/build
/tmp/build
├── L.java
├── L.tokens
├── P.java
├── P.tokens
├── PBaseListener.java
├── PListener.java
└── src
    └── pkg
        ├── L.java
        └── L.tokens
```
