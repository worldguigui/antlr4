# Writing target-agnostic grammars
# 编写目标无关的语法

[原文链接](https://github.com/antlr/antlr4/blob/master/doc/target-agnostic-grammars.md)

Some grammars require [semantic predicates](https://github.com/antlr/antlr4/blob/dev/doc/predicates.md) to add context-sensitive parsing to what would generally be a context-free grammar.
有些语法需要[语义断言](https://github.com/antlr/antlr4/blob/dev/doc/predicates.md)来为通常是上下文无关的语法添加上下文相关的解析。

For example:
例如：
* In Fortran90, [lines that begin with a 'C' in column 1 are comments](https://github.com/antlr/grammars-v4/blob/43fbb16fec1d474d38a603cc6a6bcbe5edf07b1e/fortran/fortran90/slow/hw.f90#L1), which should be placed on a token stream other than the default. But, if the 'C' does not begin in column 1, then the input is invalid and should be flagged as so.
* 在 Fortran90 中，[第 1 列以 'C' 开头的行是注释](https://github.com/antlr/grammars-v4/blob/43fbb16fec1d474d38a603cc6a6bcbe5edf07b1e/fortran/fortran90/slow/hw.f90#L1)，应放置在默认之外的词法符号流上。但是，如果 'C' 不在第 1 列开始，则输入无效并应标记为错误。
	```fortran
	c Hello World.
	   c This is a syntax error because 'c' does not start in column 1
	program hello
		print *, 'Hello World!'
	end
	```

* In CSharp, two [greater-than signs](https://util.unicode.org/UnicodeJsps/character.jsp?a=003E) `'>>'` can either mean [a right shift expression](https://github.com/antlr/grammars-v4/blob/43fbb16fec1d474d38a603cc6a6bcbe5edf07b1e/csharp/examples/AllInOneNoPreprocessor.cs#L657C15-L657C17) or [part of a type declaration with templates](https://github.com/antlr/grammars-v4/blob/master/csharp/examples/AllInOneNoPreprocessor.cs#L463C33-L463C35). Since lexers in Antlr are not parser aware, the lexer must tokenize the two greater-than signs as two separate tokens. A semantic predicate should be added to disallow a space between the two greater-than signs in the context of an expression, but allowed in the context of a type declaration.
* 在 CSharp 中，两个[大于号](https://util.unicode.org/UnicodeJsps/character.jsp?a=003E) `'>>'` 既可以表示[右移表达式](https://github.com/antlr/grammars-v4/blob/43fbb16fec1d474d38a603cc6a6bcbe5edf07b1e/csharp/examples/AllInOneNoPreprocessor.cs#L657C15-L657C17)，也可以表示[带模板的类型声明的一部分](https://github.com/antlr/grammars-v4/blob/master/csharp/examples/AllInOneNoPreprocessor.cs#L463C33-L463C35)。由于 Antlr 中的词法分析器不了解解析器，词法分析器必须将两个大于号标记为两个独立的词法符号。应添加一个语义断言，在表达式上下文中禁止两个大于号之间有空格，但在类型声明上下文中允许。
	```C#
	class Foo {
		void Func()
		{
			int x = 1000 > > 2;               // syntax error if a space exists in the double greater-than sign
		}
		Dictionary<int, List<int> > mapping;  // nested template declaration, valid
	}
	```

Antlr does not have a general-purpose language for predicates. These must be written in the target language of the generated parser. The problem is that a grammar would need to be forked for each target desired, which adds to the burden of maintenance.
Antlr 没有用于断言的通用语言。这些必须用生成解析器的目标语言编写。问题是语法需要为每个所需的目标进行分支，这增加了维护负担。

However, it is possible to write the grammar such that forking is not required, using _target-agnostic format_.
但是，可以使用*目标无关格式*编写语法，从而不需要分支。

## Rules in writing target-agnostic grammars
## 编写目标无关语法的规则

1) You will need to [split your grammar](https://github.com/antlr/antlr4/blob/dev/doc/grammars.md#grammar-structure) into separate lexer and parser grammars. Then, add `options { tokenVocab=...; }` to the parser grammar.
1) 您需要将[语法拆分](https://github.com/antlr/antlr4/blob/dev/doc/grammars.md#grammar-structure)为独立的词法分析器和解析器语法。然后，在解析器语法中添加 `options { tokenVocab=...; }`。
2) Create target-specific source code files that contain methods in a base class for the parser or lexer grammar. In these source code files, write the code for the semantic predicate. For example, the files for the Cpp target would be `Python3LexerBase.{cpp,h}`, `Python3ParserBase.{cpp,h}`.
2) 创建特定目标的源代码文件，这些文件包含解析器或词法分析器语法的基类方法。在这些源代码文件中，编写语义断言的代码。例如，Cpp 目标的文件将是 `Python3LexerBase.{cpp,h}`、`Python3ParserBase.{cpp,h}`。
3) In the grammar(s), add `options { superClass=... }`. This will [superclass the recognizer](https://github.com/antlr/antlr4/blob/dev/doc/options.md#superclass). For example, `options { superclass=Python3ParserBase; }`.
3) 在语法中，添加 `options { superClass=... }`。这将[为识别器设置超类](https://github.com/antlr/antlr4/blob/dev/doc/options.md#superclass)。例如，`options { superclass=Python3ParserBase; }`。
4) In the grammar(s), write code to make a single call to the base-class method. The call should have a `this.` string before the name of the method, e.g., `OPEN_PAREN : '(' {this.openBrace();};` The action code must not reference Antlr attributes, variables, types, or have semi-colons as statement separators or control-flow statements of any kind.
4) 在语法中，编写代码以对基类方法进行单一调用。调用应在方法名称前加上 `this.` 字符串，例如 `OPEN_PAREN : '(' {this.openBrace();};`。动作代码不得引用 Antlr 属性、变量、类型，或使用分号作为语句分隔符或任何类型的控制流语句。
5) For some targets like Cpp and PHP, you may need to add code to include source code files so that the generated code compiles. For these, add a comment such as `// Insert here @header for lexer include.` or `// Insert here @header for parser include.` to the grammar, before the first rule.
5) 对于某些目标（如 Cpp 和 PHP），您可能需要添加代码以包含源代码文件，以便生成的代码能够编译。对于这些，在语法中的第一条规则之前添加注释，例如 `// Insert here @header for lexer include.` 或 `// Insert here @header for parser include.`。
5) Add a Python script called "transformGrammar.py" that rewrites the grammar(s) with some target-specific code syntax.
5) 添加一个名为 "transformGrammar.py" 的 Python 脚本，该脚本使用一些特定目标的代码语法重写语法。
   a) For Cpp: replace `this.` strings with `this->`.
   a) 对于 Cpp：将 `this.` 字符串替换为 `this->`。
   b) For PHP: replace `this.` strings with `$this->`.
   b) 对于 PHP：将 `this.` 字符串替换为 `$this->`。
   c) For Python: replace `this.` strings with `self.`, `l.`, or `p.` depending on where the action or predicate is in the grammar.
   c) 对于 Python：根据动作或断言在语法中的位置，将 `this.` 字符串替换为 `self.`、`l.` 或 `p.`。
   d) For Cpp: replace `// Insert here @header for lexer include.` (or parser) with `@header::lexer {#include ...}`.
   d) 对于 Cpp：将 `// Insert here @header for lexer include.`（或解析器）替换为 `@header::lexer {#include ...}`。
   e) For PHP: replace `// Insert here @header for lexer include.` (or parser) with `@header::lexer {require ...}`.
   e) 对于 PHP：将 `// Insert here @header for lexer include.`（或解析器）替换为 `@header::lexer {require ...}`。
   e) Run `python transformGrammar.py *.g4` before generating the parser and lexer.
   e) 在生成解析器和词法分析器之前运行 `python transformGrammar.py *.g4`。

## Examples of target-agnostic grammars
## 目标无关语法的示例
* [fortran90](https://github.com/antlr/grammars-v4/tree/master/fortran/fortran90)
* [csharp](https://github.com/antlr/grammars-v4/tree/master/csharp)
