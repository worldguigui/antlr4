# Grammar Lexicon
# 语法词汇表

[原文链接](https://github.com/antlr/antlr4/blob/master/doc/lexicon.md)

The lexicon of ANTLR is familiar to most programmers because it follows the syntax of C and its derivatives with some extensions for grammatical descriptions.<br/>
ANTLR的词汇表对大多数程序员来说都很熟悉，因为它遵循C语言及其衍生语言的语法，并针对语法描述进行了一些扩展。

## Comments
## 注释

There are single-line, multiline, and Javadoc-style comments:<br/>
注释分为单行注释、多行注释和Javadoc风格注释：

```
/** This grammar is an example illustrating the three kinds
 * of comments.
 */
grammar T;
/* a multi-line
  comment
*/

/** This rule matches a declarator for my language */
decl : ID ; // match a variable name
```

The Javadoc comments are hidden from the parser and are ignored at the moment. They are intended to be used only at the start of the grammar and any rule.<br/>
Javadoc注释会对解析器隐藏且当前会被忽略。它们仅建议用在语法文件开头和任何规则的开头。

## Identifiers
## 标识符

Token names always start with a capital letter and so do lexer rules as defined by Java’s `Character.isUpperCase` method. Parser rule names always start with a lowercase letter (those that fail `Character.isUpperCase`). The initial character can be followed by uppercase and lowercase letters, digits, and underscores. Here are some sample names:<br/>
词法符号名称总是以大写字母开头，由Java的`Character.isUpperCase`方法定义的词法规则也是如此。解析器规则名称总是以小写字母开头（即那些不符合`Character.isUpperCase`方法的字符）。起始字符后可以跟随大小写字母、数字和下划线。以下是一些示例名称：

```
ID, LPAREN, RIGHT_CURLY // token names/lexer rules
expr, simpleDeclarator, d2, header_file // parser rule names
```

Like Java, ANTLR accepts Unicode characters in ANTLR names:<br/>
与Java类似，ANTLR接受ANTLR名称中的Unicode字符：<br/>

<img src=images/nonascii.png width=100>

To support Unicode parser and lexer rule names, ANTLR uses the following rule:<br/>
为了支持Unicode解析器和词法分析器规则名称，ANTLR使用以下规则：<br/>

```
ID : a=NameStartChar NameChar*
     {  
     if ( Character.isUpperCase(getText().charAt(0)) ) setType(TOKEN_REF);
     else setType(RULE_REF);
     }  
   ;
```

Rule `NameChar` identifies the valid identifier characters:<br/>
规则`NameChar`定义了有效的标识符字符：

```
fragment
NameChar
   : NameStartChar
   | '0'..'9'
   | '_'
   | '\u00B7'
   | '\u0300'..'\u036F'
   | '\u203F'..'\u2040'
   ;
fragment
NameStartChar
   : 'A'..'Z' | 'a'..'z'
   | '\u00C0'..'\u00D6'
   | '\u00D8'..'\u00F6'
   | '\u00F8'..'\u02FF'
   | '\u0370'..'\u037D'
   | '\u037F'..'\u1FFF'
   | '\u200C'..'\u200D'
   | '\u2070'..'\u218F'
   | '\u2C00'..'\u2FEF'
   | '\u3001'..'\uD7FF'
   | '\uF900'..'\uFDCF'
   | '\uFDF0'..'\uFFFD'
   ;
```

Rule `NameStartChar` is the list of characters that can start an identifier (rule, token, or label name):<br/>
规则`NameStartChar`是可以作为标识符（规则、词法符号或标签名称）起始字符的字符列表：<br/>
These more or less correspond to `isJavaIdentifierPart` and `isJavaIdentifierStart` in Java’s Character class. Make sure to use the `-encoding` option on the ANTLR tool if your grammar file is not in UTF-8 format, so that ANTLR reads characters properly.<br/>
这些定义大致对应于Java Character类中的`isJavaIdentifierPart`和`isJavaIdentifierStart`方法。如果您的语法文件不是UTF-8格式，请确保在ANTLR工具上使用`-encoding`选项，以便ANTLR能正确读取字符。<br/>

## Literals
## 字面量

ANTLR does not distinguish between character and string literals as most languages do. All literal strings one or more characters in length are enclosed in single quotes such as `';'`, `'if'`, `'>='`, and `'\''` (refers to the one-character string containing the single quote character). Literals never contain regular expressions.<br/>
ANTLR不像大多数语言那样区分字符和字符串字面量。所有长度为一个或多个字符的字面量字符串都用单引号括起来，例如`';'`、`'if'`、`'>='`和`'\''`（指包含单引号字符的单字符字符串）。字面量从不包含正则表达式。<br/>

Literals can contain Unicode escape sequences of the form `'\uXXXX'` (for Unicode code points up to `'U+FFFF'`) or `'\u{XXXXXX}'` (for all Unicode code points), where `'XXXX'` is the hexadecimal Unicode code point value.<br/>
字面量可以包含形式为`'\uXXXX'`（用于Unicode码点至`'U+FFFF'`）或`'\u{XXXXXX}'`（用于所有Unicode码点）的Unicode转义序列，其中`'XXXX'`是十六进制的Unicode码点值。<br/>

For example, `'\u00E8'` is the French letter with a grave accent: `'è'`, and `'\u{1F4A9}'` is the famous emoji: `'💩'`.<br/>
例如，`'\u00E8'`是带有重音符号的法语字母：`'è'`，而`'\u{1F4A9}'`是著名的表情符号：`'💩'`。<br/>

ANTLR also understands the usual special escape sequences: `'\n'` (newline), `'\r'` (carriage return), `'\t'` (tab), `'\b'` (backspace), and `'\f'` (form feed). You can use Unicode code points directly within literals or use the Unicode escape sequences:<br/>
ANTLR也能识别常用的特殊转义序列：`'\n'`（换行）、`'\r'`（回车）、`'\t'`（制表符）、`'\b'`（退格）和`'\f'`（换页）。您可以直接在字面量中使用Unicode码点，或使用Unicode转义序列：<br/>

```
grammar Foreign;
a : '外' ;
```

The recognizers that ANTLR generates assume a character vocabulary containing all Unicode characters. The input file encoding assumed by the runtime library depends on the target language. For the Java target, the runtime library assumes files are in UTF-8. Using the factory methods in `CharStreams`, you can specify a different encoding.<br/>
ANTLR生成的识别器假定字符集包含所有Unicode字符。运行时库假定的输入文件编码取决于目标语言。对于Java目标，运行时库假定文件为UTF-8编码。使用`CharStreams`中的工厂方法，您可以指定不同的编码。<br/>

## Actions
## 动作

Actions are code blocks written in the target language. You can use actions in a number of places within a grammar, but the syntax is always the same: arbitrary text surrounded by curly braces. You don’t need to escape a closing curly character if it’s in a string or comment: `"}"` or `/*}*/`. If the curlies are balanced, you also don’t need to escape }: `{...}`. Otherwise, escape extra curlies with a backslash: `\{` or `\}`. The action text should conform to the target language as specified with the language option.<br/>
动作是用目标语言编写的代码块。您可以在语法中的多个位置使用动作，但语法始终相同：用花括号括起的任意文本。如果右花括号在字符串或注释中，则不需要转义：`"}"`或`/*}*/`。如果花括号是平衡的，您也不需要转义：`{...}`。否则，使用反斜杠转义额外的花括号：`\{`或`\}`。动作文本应符合通过language选项指定的目标语言。<br/>

Embedded code can appear in: `@header` and `@members` named actions, parser and lexer rules, exception catching specifications, attribute sections for parser rules (return values, arguments, and locals), and some rule element options (currently predicates).<br/>
嵌入式代码可以出现在：`@header`和`@members`命名动作、解析器和词法分析器规则、异常捕获规范、解析器规则的属性部分（返回值、参数和局部变量）以及某些规则元素选项（当前为断言）中。<br/>

The only interpretation ANTLR does inside actions relates to grammar attributes; see [Token Attributes](http://pragprog.com/book/tpantlr2/the-definitive-antlr-4-reference) and Chapter 10, [Attributes and Actions](http://pragprog.com/book/tpantlr2/the-definitive-antlr-4-reference). Actions embedded within lexer rules are emitted without any interpretation or translation into generated lexers.<br/>
ANTLR在动作内部进行的唯一解释与语法属性有关；请参阅[词法符号属性](http://pragprog.com/book/tpantlr2/the-definitive-antlr-4-reference)和第10章[属性与动作]<br/>(http://pragprog.com/book/tpantlr2/the-definitive-antlr-4-reference)。嵌入在词法规则中的动作会直接输出，不经任何解释或转换到生成的词法分析器中。

## Keywords
## 关键字

Here’s a list of the reserved words in ANTLR grammars:<br/>
以下是ANTLR语法中的保留字列表：

```
import, fragment, lexer, parser, grammar, returns,
locals, throws, catch, finally, mode, options, tokens
```
  
Also, although it is not a keyword, do not use the word `rule` as a rule name. Further, do not use any keyword of the target language as a token, label, or rule name. For example, rule `if` would result in a generated function called `if`. That would not compile obviously.<br/>
另外，尽管`rule`不是关键字，但不要将其用作规则名称。此外，不要使用目标语言的任何关键字作为词法符号、标签或规则名称。例如，规则`if`将生成一个名为`if`的函数，这显然无法通过编译。<br/>
