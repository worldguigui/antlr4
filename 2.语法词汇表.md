# Grammar Lexicon
# è¯­æ³•è¯æ±‡è¡¨

[åŸæ–‡é“¾æ¥](https://github.com/antlr/antlr4/blob/master/doc/lexicon.md)

The lexicon of ANTLR is familiar to most programmers because it follows the syntax of C and its derivatives with some extensions for grammatical descriptions.<br/>
ANTLRçš„è¯æ±‡è¡¨å¯¹å¤§å¤šæ•°ç¨‹åºå‘˜æ¥è¯´éƒ½å¾ˆç†Ÿæ‚‰ï¼Œå› ä¸ºå®ƒéµå¾ªCè¯­è¨€åŠå…¶è¡ç”Ÿè¯­è¨€çš„è¯­æ³•ï¼Œå¹¶é’ˆå¯¹è¯­æ³•æè¿°è¿›è¡Œäº†ä¸€äº›æ‰©å±•ã€‚

## Comments
## æ³¨é‡Š

There are single-line, multiline, and Javadoc-style comments:<br/>
æ³¨é‡Šåˆ†ä¸ºå•è¡Œæ³¨é‡Šã€å¤šè¡Œæ³¨é‡Šå’ŒJavadocé£æ ¼æ³¨é‡Šï¼š

```
/** This grammar is an example illustrating the three kinds
 * of comments.
 */
grammar T;
/* a multi-line
  comment
*/

/** This rule matches a declarator for my language */
decl : ID ; // match a variable name
```

The Javadoc comments are hidden from the parser and are ignored at the moment. They are intended to be used only at the start of the grammar and any rule.<br/>
Javadocæ³¨é‡Šä¼šå¯¹è§£æå™¨éšè—ä¸”å½“å‰ä¼šè¢«å¿½ç•¥ã€‚å®ƒä»¬ä»…å»ºè®®ç”¨åœ¨è¯­æ³•æ–‡ä»¶å¼€å¤´å’Œä»»ä½•è§„åˆ™çš„å¼€å¤´ã€‚

## Identifiers
## æ ‡è¯†ç¬¦

Token names always start with a capital letter and so do lexer rules as defined by Javaâ€™s `Character.isUpperCase` method. Parser rule names always start with a lowercase letter (those that fail `Character.isUpperCase`). The initial character can be followed by uppercase and lowercase letters, digits, and underscores. Here are some sample names:<br/>
è¯æ³•ç¬¦å·åç§°æ€»æ˜¯ä»¥å¤§å†™å­—æ¯å¼€å¤´ï¼Œç”±Javaçš„`Character.isUpperCase`æ–¹æ³•å®šä¹‰çš„è¯æ³•è§„åˆ™ä¹Ÿæ˜¯å¦‚æ­¤ã€‚è§£æå™¨è§„åˆ™åç§°æ€»æ˜¯ä»¥å°å†™å­—æ¯å¼€å¤´ï¼ˆå³é‚£äº›ä¸ç¬¦åˆ`Character.isUpperCase`æ–¹æ³•çš„å­—ç¬¦ï¼‰ã€‚èµ·å§‹å­—ç¬¦åå¯ä»¥è·Ÿéšå¤§å°å†™å­—æ¯ã€æ•°å­—å’Œä¸‹åˆ’çº¿ã€‚ä»¥ä¸‹æ˜¯ä¸€äº›ç¤ºä¾‹åç§°ï¼š

```
ID, LPAREN, RIGHT_CURLY // token names/lexer rules
expr, simpleDeclarator, d2, header_file // parser rule names
```

Like Java, ANTLR accepts Unicode characters in ANTLR names:<br/>
ä¸Javaç±»ä¼¼ï¼ŒANTLRæ¥å—ANTLRåç§°ä¸­çš„Unicodeå­—ç¬¦ï¼š<br/>

<img src=images/nonascii.png width=100>

To support Unicode parser and lexer rule names, ANTLR uses the following rule:<br/>
ä¸ºäº†æ”¯æŒUnicodeè§£æå™¨å’Œè¯æ³•åˆ†æå™¨è§„åˆ™åç§°ï¼ŒANTLRä½¿ç”¨ä»¥ä¸‹è§„åˆ™ï¼š<br/>

```
ID : a=NameStartChar NameChar*
     {  
     if ( Character.isUpperCase(getText().charAt(0)) ) setType(TOKEN_REF);
     else setType(RULE_REF);
     }  
   ;
```

Rule `NameChar` identifies the valid identifier characters:<br/>
è§„åˆ™`NameChar`å®šä¹‰äº†æœ‰æ•ˆçš„æ ‡è¯†ç¬¦å­—ç¬¦ï¼š

```
fragment
NameChar
   : NameStartChar
   | '0'..'9'
   | '_'
   | '\u00B7'
   | '\u0300'..'\u036F'
   | '\u203F'..'\u2040'
   ;
fragment
NameStartChar
   : 'A'..'Z' | 'a'..'z'
   | '\u00C0'..'\u00D6'
   | '\u00D8'..'\u00F6'
   | '\u00F8'..'\u02FF'
   | '\u0370'..'\u037D'
   | '\u037F'..'\u1FFF'
   | '\u200C'..'\u200D'
   | '\u2070'..'\u218F'
   | '\u2C00'..'\u2FEF'
   | '\u3001'..'\uD7FF'
   | '\uF900'..'\uFDCF'
   | '\uFDF0'..'\uFFFD'
   ;
```

Rule `NameStartChar` is the list of characters that can start an identifier (rule, token, or label name):<br/>
è§„åˆ™`NameStartChar`æ˜¯å¯ä»¥ä½œä¸ºæ ‡è¯†ç¬¦ï¼ˆè§„åˆ™ã€è¯æ³•ç¬¦å·æˆ–æ ‡ç­¾åç§°ï¼‰èµ·å§‹å­—ç¬¦çš„å­—ç¬¦åˆ—è¡¨ï¼š<br/>
These more or less correspond to `isJavaIdentifierPart` and `isJavaIdentifierStart` in Javaâ€™s Character class. Make sure to use the `-encoding` option on the ANTLR tool if your grammar file is not in UTF-8 format, so that ANTLR reads characters properly.<br/>
è¿™äº›å®šä¹‰å¤§è‡´å¯¹åº”äºJava Characterç±»ä¸­çš„`isJavaIdentifierPart`å’Œ`isJavaIdentifierStart`æ–¹æ³•ã€‚å¦‚æœæ‚¨çš„è¯­æ³•æ–‡ä»¶ä¸æ˜¯UTF-8æ ¼å¼ï¼Œè¯·ç¡®ä¿åœ¨ANTLRå·¥å…·ä¸Šä½¿ç”¨`-encoding`é€‰é¡¹ï¼Œä»¥ä¾¿ANTLRèƒ½æ­£ç¡®è¯»å–å­—ç¬¦ã€‚<br/>

## Literals
## å­—é¢é‡

ANTLR does not distinguish between character and string literals as most languages do. All literal strings one or more characters in length are enclosed in single quotes such as `';'`, `'if'`, `'>='`, and `'\''` (refers to the one-character string containing the single quote character). Literals never contain regular expressions.<br/>
ANTLRä¸åƒå¤§å¤šæ•°è¯­è¨€é‚£æ ·åŒºåˆ†å­—ç¬¦å’Œå­—ç¬¦ä¸²å­—é¢é‡ã€‚æ‰€æœ‰é•¿åº¦ä¸ºä¸€ä¸ªæˆ–å¤šä¸ªå­—ç¬¦çš„å­—é¢é‡å­—ç¬¦ä¸²éƒ½ç”¨å•å¼•å·æ‹¬èµ·æ¥ï¼Œä¾‹å¦‚`';'`ã€`'if'`ã€`'>='`å’Œ`'\''`ï¼ˆæŒ‡åŒ…å«å•å¼•å·å­—ç¬¦çš„å•å­—ç¬¦å­—ç¬¦ä¸²ï¼‰ã€‚å­—é¢é‡ä»ä¸åŒ…å«æ­£åˆ™è¡¨è¾¾å¼ã€‚<br/>

Literals can contain Unicode escape sequences of the form `'\uXXXX'` (for Unicode code points up to `'U+FFFF'`) or `'\u{XXXXXX}'` (for all Unicode code points), where `'XXXX'` is the hexadecimal Unicode code point value.<br/>
å­—é¢é‡å¯ä»¥åŒ…å«å½¢å¼ä¸º`'\uXXXX'`ï¼ˆç”¨äºUnicodeç ç‚¹è‡³`'U+FFFF'`ï¼‰æˆ–`'\u{XXXXXX}'`ï¼ˆç”¨äºæ‰€æœ‰Unicodeç ç‚¹ï¼‰çš„Unicodeè½¬ä¹‰åºåˆ—ï¼Œå…¶ä¸­`'XXXX'`æ˜¯åå…­è¿›åˆ¶çš„Unicodeç ç‚¹å€¼ã€‚<br/>

For example, `'\u00E8'` is the French letter with a grave accent: `'Ã¨'`, and `'\u{1F4A9}'` is the famous emoji: `'ğŸ’©'`.<br/>
ä¾‹å¦‚ï¼Œ`'\u00E8'`æ˜¯å¸¦æœ‰é‡éŸ³ç¬¦å·çš„æ³•è¯­å­—æ¯ï¼š`'Ã¨'`ï¼Œè€Œ`'\u{1F4A9}'`æ˜¯è‘—åçš„è¡¨æƒ…ç¬¦å·ï¼š`'ğŸ’©'`ã€‚<br/>

ANTLR also understands the usual special escape sequences: `'\n'` (newline), `'\r'` (carriage return), `'\t'` (tab), `'\b'` (backspace), and `'\f'` (form feed). You can use Unicode code points directly within literals or use the Unicode escape sequences:<br/>
ANTLRä¹Ÿèƒ½è¯†åˆ«å¸¸ç”¨çš„ç‰¹æ®Šè½¬ä¹‰åºåˆ—ï¼š`'\n'`ï¼ˆæ¢è¡Œï¼‰ã€`'\r'`ï¼ˆå›è½¦ï¼‰ã€`'\t'`ï¼ˆåˆ¶è¡¨ç¬¦ï¼‰ã€`'\b'`ï¼ˆé€€æ ¼ï¼‰å’Œ`'\f'`ï¼ˆæ¢é¡µï¼‰ã€‚æ‚¨å¯ä»¥ç›´æ¥åœ¨å­—é¢é‡ä¸­ä½¿ç”¨Unicodeç ç‚¹ï¼Œæˆ–ä½¿ç”¨Unicodeè½¬ä¹‰åºåˆ—ï¼š<br/>

```
grammar Foreign;
a : 'å¤–' ;
```

The recognizers that ANTLR generates assume a character vocabulary containing all Unicode characters. The input file encoding assumed by the runtime library depends on the target language. For the Java target, the runtime library assumes files are in UTF-8. Using the factory methods in `CharStreams`, you can specify a different encoding.<br/>
ANTLRç”Ÿæˆçš„è¯†åˆ«å™¨å‡å®šå­—ç¬¦é›†åŒ…å«æ‰€æœ‰Unicodeå­—ç¬¦ã€‚è¿è¡Œæ—¶åº“å‡å®šçš„è¾“å…¥æ–‡ä»¶ç¼–ç å–å†³äºç›®æ ‡è¯­è¨€ã€‚å¯¹äºJavaç›®æ ‡ï¼Œè¿è¡Œæ—¶åº“å‡å®šæ–‡ä»¶ä¸ºUTF-8ç¼–ç ã€‚ä½¿ç”¨`CharStreams`ä¸­çš„å·¥å‚æ–¹æ³•ï¼Œæ‚¨å¯ä»¥æŒ‡å®šä¸åŒçš„ç¼–ç ã€‚<br/>

## Actions
## åŠ¨ä½œ

Actions are code blocks written in the target language. You can use actions in a number of places within a grammar, but the syntax is always the same: arbitrary text surrounded by curly braces. You donâ€™t need to escape a closing curly character if itâ€™s in a string or comment: `"}"` or `/*}*/`. If the curlies are balanced, you also donâ€™t need to escape }: `{...}`. Otherwise, escape extra curlies with a backslash: `\{` or `\}`. The action text should conform to the target language as specified with the language option.<br/>
åŠ¨ä½œæ˜¯ç”¨ç›®æ ‡è¯­è¨€ç¼–å†™çš„ä»£ç å—ã€‚æ‚¨å¯ä»¥åœ¨è¯­æ³•ä¸­çš„å¤šä¸ªä½ç½®ä½¿ç”¨åŠ¨ä½œï¼Œä½†è¯­æ³•å§‹ç»ˆç›¸åŒï¼šç”¨èŠ±æ‹¬å·æ‹¬èµ·çš„ä»»æ„æ–‡æœ¬ã€‚å¦‚æœå³èŠ±æ‹¬å·åœ¨å­—ç¬¦ä¸²æˆ–æ³¨é‡Šä¸­ï¼Œåˆ™ä¸éœ€è¦è½¬ä¹‰ï¼š`"}"`æˆ–`/*}*/`ã€‚å¦‚æœèŠ±æ‹¬å·æ˜¯å¹³è¡¡çš„ï¼Œæ‚¨ä¹Ÿä¸éœ€è¦è½¬ä¹‰ï¼š`{...}`ã€‚å¦åˆ™ï¼Œä½¿ç”¨åæ–œæ è½¬ä¹‰é¢å¤–çš„èŠ±æ‹¬å·ï¼š`\{`æˆ–`\}`ã€‚åŠ¨ä½œæ–‡æœ¬åº”ç¬¦åˆé€šè¿‡languageé€‰é¡¹æŒ‡å®šçš„ç›®æ ‡è¯­è¨€ã€‚<br/>

Embedded code can appear in: `@header` and `@members` named actions, parser and lexer rules, exception catching specifications, attribute sections for parser rules (return values, arguments, and locals), and some rule element options (currently predicates).<br/>
åµŒå…¥å¼ä»£ç å¯ä»¥å‡ºç°åœ¨ï¼š`@header`å’Œ`@members`å‘½ååŠ¨ä½œã€è§£æå™¨å’Œè¯æ³•åˆ†æå™¨è§„åˆ™ã€å¼‚å¸¸æ•è·è§„èŒƒã€è§£æå™¨è§„åˆ™çš„å±æ€§éƒ¨åˆ†ï¼ˆè¿”å›å€¼ã€å‚æ•°å’Œå±€éƒ¨å˜é‡ï¼‰ä»¥åŠæŸäº›è§„åˆ™å…ƒç´ é€‰é¡¹ï¼ˆå½“å‰ä¸ºæ–­è¨€ï¼‰ä¸­ã€‚<br/>

The only interpretation ANTLR does inside actions relates to grammar attributes; see [Token Attributes](http://pragprog.com/book/tpantlr2/the-definitive-antlr-4-reference) and Chapter 10, [Attributes and Actions](http://pragprog.com/book/tpantlr2/the-definitive-antlr-4-reference). Actions embedded within lexer rules are emitted without any interpretation or translation into generated lexers.<br/>
ANTLRåœ¨åŠ¨ä½œå†…éƒ¨è¿›è¡Œçš„å”¯ä¸€è§£é‡Šä¸è¯­æ³•å±æ€§æœ‰å…³ï¼›è¯·å‚é˜…[è¯æ³•ç¬¦å·å±æ€§](http://pragprog.com/book/tpantlr2/the-definitive-antlr-4-reference)å’Œç¬¬10ç« [å±æ€§ä¸åŠ¨ä½œ]<br/>(http://pragprog.com/book/tpantlr2/the-definitive-antlr-4-reference)ã€‚åµŒå…¥åœ¨è¯æ³•è§„åˆ™ä¸­çš„åŠ¨ä½œä¼šç›´æ¥è¾“å‡ºï¼Œä¸ç»ä»»ä½•è§£é‡Šæˆ–è½¬æ¢åˆ°ç”Ÿæˆçš„è¯æ³•åˆ†æå™¨ä¸­ã€‚

## Keywords
## å…³é”®å­—

Hereâ€™s a list of the reserved words in ANTLR grammars:<br/>
ä»¥ä¸‹æ˜¯ANTLRè¯­æ³•ä¸­çš„ä¿ç•™å­—åˆ—è¡¨ï¼š

```
import, fragment, lexer, parser, grammar, returns,
locals, throws, catch, finally, mode, options, tokens
```
  
Also, although it is not a keyword, do not use the word `rule` as a rule name. Further, do not use any keyword of the target language as a token, label, or rule name. For example, rule `if` would result in a generated function called `if`. That would not compile obviously.<br/>
å¦å¤–ï¼Œå°½ç®¡`rule`ä¸æ˜¯å…³é”®å­—ï¼Œä½†ä¸è¦å°†å…¶ç”¨ä½œè§„åˆ™åç§°ã€‚æ­¤å¤–ï¼Œä¸è¦ä½¿ç”¨ç›®æ ‡è¯­è¨€çš„ä»»ä½•å…³é”®å­—ä½œä¸ºè¯æ³•ç¬¦å·ã€æ ‡ç­¾æˆ–è§„åˆ™åç§°ã€‚ä¾‹å¦‚ï¼Œè§„åˆ™`if`å°†ç”Ÿæˆä¸€ä¸ªåä¸º`if`çš„å‡½æ•°ï¼Œè¿™æ˜¾ç„¶æ— æ³•é€šè¿‡ç¼–è¯‘ã€‚<br/>
