# Grammar Structure
# 语法结构

[原文链接](https://github.com/antlr/antlr4/blob/master/doc/grammars.md)

A grammar is essentially a grammar declaration followed by a list of rules, but has the general form:<br/>
语法本质上由一个语法声明后跟一系列规则组成，但具有以下通用形式：<br/>

```
/** Optional javadoc style comment */
grammar Name; ①
options {...}
import ... ;
 	
tokens {...}
channels {...} // lexer only
@actionName {...}
 	 
rule1 // parser and lexer rules, possibly intermingled
...
ruleN
```

The file name containing grammar `X` must be called `X.g4`. You can specify options, imports, token specifications, and actions in any order. There can be at most one each of options, imports, and token specifications. All of those elements are optional except for the header ① and at least one rule. Rules take the basic form:<br/>
包含语法`X`的文件名必须称为`X.g4`。您可以按任意顺序指定选项、导入、词法符号规范和作用。选项、导入和词法符号规范每种最多只能有一个。除了标头①和至少一条规则外，所有这些元素都是可选的。规则采用以下基本形式：<br/>

```
ruleName : alternative1 | ... | alternativeN ;
```

Parser rule names must start with a lowercase letter and lexer rules must start with a capital letter.<br/>
解析器规则名称必须以小写字母开头，词法规则必须以大写字母开头。<br/>

Grammars defined without a prefix on the `grammar` header are combined grammars that can contain both lexical and parser rules. To make a parser grammar that only allows parser rules, use the following header.<br/>
在`grammar`标头中没有前缀定义的语法是组合语法，可以同时包含词法和解析器规则。要创建仅允许解析器规则的解析器语法，请使用以下标头。<br/>

```
parser grammar Name;
...
```

And, naturally, a pure lexer grammar looks like this:<br/>
并且，自然地，纯词法语法如下所示：<br/>

```
lexer grammar Name;
...
```

Only lexer grammars can contain `mode` specifications.<br/>
只有词法语法可以包含`mode`规范。<br/>

Only lexer grammars can contain custom channels specifications<br/>
只有词法语法可以包含自定义通道规范<br/>

```
channels {
  WHITESPACE_CHANNEL,
  COMMENTS_CHANNEL
}
```

Those channels can then be used like enums within lexer rules:<br/>
然后这些通道可以像枚举一样在词法规则中使用：<br/>

```
WS : [ \r\t\n]+ -> channel(WHITESPACE_CHANNEL) ;
```

Sections 15.5, [Lexer Rules](http://pragprog.com/book/tpantlr2/the-definitive-antlr-4-reference) and Section 15.3, [Parser Rules](http://pragprog.com/book/tpantlr2/the-definitive-antlr-4-reference) contain details on rule syntax. Section 15.8, Options describes grammar options and Section 15.4, Actions and Attributes has information on grammar-level actions.<br/>
第15.5节[词法规则](http://pragprog.com/book/tpantlr2/the-definitive-antlr-4-reference)和第15.3节[解析器规则](http://pragprog.com/book/tpantlr2/the-definitive-antlr-4-reference)包含规则语法的详细信息。第15.8节选项描述了语法选项，第15.4节动作和属性提供了关于语法级动作的信息。<br/>

## Grammar Imports
## 语法导入

Grammar `imports` let you break up a grammar into logical and reusable chunks, as we saw in [Importing Grammars](http://pragprog.com/book/tpantlr2/the-definitive-antlr-4-reference). ANTLR treats imported grammars very much like object-oriented programming languages treat superclasses. A grammar inherits all of the rules, tokens specifications, and named actions from the imported grammar. Rules in the “main grammar” override rules from imported grammars to implement inheritance.<br/>
语法`imports`允许您将语法分解为逻辑上可重用的块，正如我们在[导入语法](http://pragprog.com/book/tpantlr2/the-definitive-antlr-4-reference)中看到的那样。ANTLR对待导入语法的方式非常类似于面向对象编程语言对待超类的方式。语法从导入的语法继承所有规则、词法符号规范和命名动作。"主语法"中的规则会覆盖导入语法中的规则以实现继承。<br/>

Think of `import` as more like a smart include statement (which does not include rules that are already defined). The result of all imports is a single combined grammar; the ANTLR code generator sees a complete grammar and has no idea there were imported grammars.<br/>
可以将`import`视为更类似于智能包含语句（它不包含已定义的规则）。所有导入的结果是一个单一的组合语法；ANTLR代码生成器看到的是一个完整的语法，并不知道存在导入的语法。<br/>

To process a main grammar, the ANTLR tool loads all of the imported grammars into subordinate grammar objects. It then merges the rules, token types, and named actions from the imported grammars into the main grammar. In the diagram below, the grammar on the right illustrates the effect of grammar `MyELang` importing grammar `ELang`.<br/>
为了处理主语法，ANTLR工具将所有导入的语法加载到从属语法对象中。然后它将导入语法中的规则、词法符号类型和命名动作合并到主语法中。在下图中，右侧的语法说明了语法`MyELang`导入语法`ELang`的效果。<br/>

<img src=images/combined.png width=400>

`MyELang` inherits rules `stat`, `WS`, and `ID`, but overrides rule `expr` and adds `INT`. Here’s a sample build and test run that shows `MyELang` can recognize integer expressions whereas the original `ELang` can’t. The third, erroneous input statement triggers an error message that also demonstrates the parser was looking for `MyELang`’s expr not `ELang`’s.<br/>
`MyELang`继承了规则`stat`、`WS`和`ID`，但覆盖了规则`expr`并添加了`INT`。以下是一个示例构建和测试运行，显示`MyELang`可以识别整数表达式，而原始`ELang`不能。第三个错误的输入语句触发的错误消息也表明解析器正在寻找`MyELang`的expr而不是`ELang`的。<br/>

```
$ antlr4 MyELang.g4
$ javac MyELang*.java
$ grun MyELang stat
=> 	34;
=> 	a;
=> 	;
=> 	EOF
<= 	line 3:0 extraneous input ';' expecting {INT, ID}
```

If there are modes in the main grammar or any of the imported grammars then the import process will import those modes and merge their rules where they are not overridden. In the event any mode becomes empty as all its rules have been overridden by rules outside the mode this mode will be discarded.<br/>
如果主语法或任何导入的语法中存在模式，那么导入过程将导入这些模式并合并其中未被覆盖的规则。如果任何模式因为其所有规则都被模式外的规则覆盖而变为空，则该模式将被丢弃。<br/>

If there were any `tokens` specifications, the main grammar would merge the token sets. If there were any `channel` specifications, the main grammar would merge the channel sets. Any named actions such as `@members` would be merged. In general, you should avoid named actions and actions within rules in imported grammars since that limits their reuse. ANTLR also ignores any options in imported grammars.<br/>
如果有任何`tokens`规范，主语法将合并词法符号集。如果有任何`channel`规范，主语法将合并通道集。任何命名动作（如`@members`）都将被合并。通常，您应避免在导入语法的规则中使用命名动作和动作，因为这会限制它们的重用性。ANTLR也会忽略导入语法中的任何选项。<br/>

Imported grammars can also import other grammars. ANTLR pursues all imported grammars in a depth-first fashion. If two or more imported grammars define rule `r`, ANTLR chooses the first version of `r` it finds. In the following diagram, ANTLR examines grammars in the following order `Nested`, `G1`, `G3`, `G2`.<br/>
导入的语法也可以导入其他语法。ANTLR以深度优先的方式处理所有导入的语法。如果两个或更多导入的语法定义了规则`r`，ANTLR会选择它找到的第一个`r`版本。在下图中，ANTLR按以下顺序检查语法：`Nested`、`G1`、`G3`、`G2`。<br/>

<img src=images/nested.png width=350>

`Nested` includes the `r` rule from `G3` because it sees that version before the `r` in `G2`.<br/>
`Nested`包含了来自`G3`的`r`规则，因为它在看到`G2`中的`r`之前看到了这个版本。<br/>

Not every kind of grammar can import every other kind of grammar:<br/>
并非每种语法都可以导入所有其他类型的语法：<br/>

* Lexer grammars can import lexers, including lexers containing modes.<br/>
* Parsers can import parsers.<br/>
* Combined grammars can import parsers or lexers without modes.<br/>
* 词法语法可以导入词法分析器，包括包含模式的词法分析器。<br/>
* 解析器可以导入解析器。<br/>
* 组合语法可以导入不包含模式的解析器或词法分析器。<br/>

ANTLR adds imported rules to the end of the rule list in a main lexer grammar. That means lexer rules in the main grammar get precedence over imported rules. For example, if a main grammar defines rule `IF : 'if' ;` and an imported grammar defines rule `ID : [a-z]+ ;` (which also recognizes `if`), the imported `ID` won’t hide the main grammar’s `IF` token definition.<br/>
ANTLR将导入的规则添加到主词法语法的规则列表末尾。这意味着主语法中的词法规则优先于导入的规则。例如，如果主语法定义了规则`IF : 'if' ;`，而导入的语法定义了规则`ID : [a-z]+ ;`（该规则也能识别`if`），导入的`ID`不会隐藏主语法的`IF`词法符号定义。<br/>

## Tokens Section
## 词法符号部分

The purpose of the `tokens` section is to define token types needed by a grammar for which there is no associated lexical rule. The basic syntax is:<br/>
`tokens`部分的目的是为语法定义没有关联词法规则的词法符号类型。基本语法是：<br/>

```
tokens { Token1, ..., TokenN }
```

Most of the time, the tokens section is used to define token types needed by actions in the grammar as shown in Section 10.3, [Recognizing Languages whose Keywords Aren’t Fixed](http://pragprog.com/book/tpantlr2/the-definitive-antlr-4-reference):<br/>
大多数时候，tokens部分用于定义语法中动作所需的词法符号类型，如第10.3节[识别关键字不固定的语言](http://pragprog.com/book/tpantlr2/the-definitive-antlr-4-reference)所示：<br/>

```
// explicitly define keyword token types to avoid implicit definition warnings
tokens { BEGIN, END, IF, THEN, WHILE }
 
@lexer::members { // keywords map used in lexer to assign token types
Map<String,Integer> keywords = new HashMap<String,Integer>() {{
	put("begin", KeywordsParser.BEGIN);
	put("end", KeywordsParser.END);
	...
}};
}
```

The `tokens` section really just defines a set of tokens to add to the overall set.<br/>
`tokens`部分实际上只是定义了一组要添加到整体集合中的词法符号。<br/>

```
$ cat Tok.g4
grammar Tok;
tokens { A, B, C }
a : X ;
$ antlr4 Tok.g4
warning(125): Tok.g4:3:4: implicit definition of token X in parser
$ cat Tok.tokens
A=1
B=2
C=3
X=4
```

## Actions at the Grammar Level
## 语法级别的动作

Currently there are only two defined named actions (for the Java target) used outside of grammar rules: `header` and `members`. The former injects code into the generated recognizer class file, before the recognizer class definition, and the latter injects code into the recognizer class definition, as fields and methods.<br/>
目前（对于Java目标）在语法规则外部只有两个已定义的命名动作：`header`和`members`。前者将代码注入到生成的识别器类文件中，位于识别器类定义之前，后者将代码作为字段和方法注入到识别器类定义中。<br/>

For combined grammars, ANTLR injects the actions into both the parser and the lexer. To restrict an action to the generated parser or lexer, use `@parser::name` or `@lexer::name`.<br/>
对于组合语法，ANTLR将动作注入到解析器和词法分析器两者中。要将动作限制在生成的解析器或词法分析器中，请使用`@parser::name`或`@lexer::name`。<br/>

Here’s an example where the grammar specifies a package for the generated code:<br/>
以下是一个示例，其中语法为生成的代码指定了包：<br/>

```
grammar Count;
 
@header {
package foo;
}
 
@members {
int count = 0;
}
 
list
@after {System.out.println(count+" ints");}
: INT {count++;} (',' INT {count++;} )*
;
 
INT : [0-9]+ ;
WS : [ \r\t\n]+ -> skip ;
```

The grammar itself then should be in directory `foo` so that ANTLR generates code in that same `foo` directory (at least when not using the `-o` ANTLR tool option):<br/>
然后语法本身应该在`foo`目录中，以便ANTLR在同一个`foo`目录中生成代码（至少在不使用`-o` ANTLR工具选项时）：<br/>

```
$ cd foo
$ antlr4 Count.g4 # generates code in the current directory (foo)
$ ls
Count.g4		CountLexer.java	CountParser.java
Count.tokens	CountLexer.tokens
CountBaseListener.java CountListener.java
$ javac *.java
$ cd ..
$ grun foo.Count list
=> 	9, 10, 11
=> 	EOF
<= 	3 ints
```

The Java compiler expects classes in package `foo` to be in directory `foo`.<br/>
Java编译器期望包`foo`中的类位于`foo`目录中。<br/>
