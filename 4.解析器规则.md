# Parser Rules
# 解析器规则

[原文链接](https://github.com/antlr/antlr4/blob/master/doc/parser-rules.md)

Parsers consist of a set of parser rules either in a parser or a combined grammar. A Java application launches a parser by invoking the rule function, generated by ANTLR, associated with the desired start rule. The most basic rule is just a rule name followed by a single alternative terminated with a semicolon:
解析器由一组解析器规则组成，这些规则可以位于解析器语法或组合语法中。Java 应用程序通过调用与所需起始规则关联的、由 ANTLR 生成的规则函数来启动解析器。最基本的规则只是一个规则名称后跟一个以分号结尾的单一选项：

```
 	/** Javadoc comment can precede rule */
 	retstat : 'return' expr ';' ;
```

Rules can also have alternatives separated by the | operator:
规则也可以有由 | 运算符分隔的选项：

```
 	stat: retstat
 	| 'break' ';'
 	| 'continue' ';'
 	;
```

Alternatives are either a list of rule elements or empty. For example, here’s a rule with an empty alternative that makes the entire rule optional:
选项可以是规则元素列表或为空。例如，这里有一个包含空选项的规则，使得整个规则成为可选的：

```
superClass
 	: 'extends' ID
 	| // empty means other alternative(s) are optional
 	;
```

## Alternative Labels
## 选项标签

As we saw in Section 7.4, Labeling Rule Alternatives for Precise Event Methods, we can get more precise parse-tree listener events by labeling the outermost alternatives of a rule using the # operator. All alternatives within a rule must be labeled, or none of them. Here are two rules with labeled alternatives.
正如我们在第 7.4 节"为精确事件方法标记规则选项"中看到的，我们可以通过使用 # 运算符标记规则的最外层选项来获得更精确的解析树监听器事件。规则中的所有选项必须全部标记，或者全部不标记。以下是两个带有标签选项的规则。

```
grammar T;
stat: 'return' e ';' # Return
 	| 'break' ';' # Break
 	;
e   : e '*' e # Mult
    | e '+' e # Add
    | INT # Int
    ;
```

Alternative labels do not have to be at the end of the line and there does not have to be a space after the # symbol.
ANTLR generates a rule context class definition for each label. For example, here is the listener that ANTLR generates:
选项标签不必位于行尾，并且 # 符号后不必有空格。
ANTLR 为每个标签生成一个规则上下文类定义。例如，以下是 ANTLR 生成的监听器：

```java
public interface AListener extends ParseTreeListener {
 	void enterReturn(AParser.ReturnContext ctx);
 	void exitReturn(AParser.ReturnContext ctx);
 	void enterBreak(AParser.BreakContext ctx);
 	void exitBreak(AParser.BreakContext ctx);
 	void enterMult(AParser.MultContext ctx);
 	void exitMult(AParser.MultContext ctx);
 	void enterAdd(AParser.AddContext ctx);
 	void exitAdd(AParser.AddContext ctx);
 	void enterInt(AParser.IntContext ctx);
 	void exitInt(AParser.IntContext ctx);
}
```

There are enter and exit methods associated with each labeled alternative. The parameters to those methods are specific to alternatives.
每个带标签的选项都有对应的 enter 和 exit 方法。这些方法的参数特定于各个选项。

You can reuse the same label on multiple alternatives to indicate that the parse tree walker should trigger the same event for those alternatives. For example, here’s a variation on rule e from grammar A above:
您可以在多个选项上重复使用相同的标签，以指示解析树遍历器应为这些选项触发相同的事件。例如，这是上面语法 A 中规则 e 的一个变体：

```
 	e : e '*' e # BinaryOp
 	| e '+' e # BinaryOp
 	| INT # Int
 	;
```

ANTLR would generate the following listener methods for e:
ANTLR 会为 e 生成以下监听器方法：

```java
 	void enterBinaryOp(AParser.BinaryOpContext ctx);
 	void exitBinaryOp(AParser.BinaryOpContext ctx);
 	void enterInt(AParser.IntContext ctx);
 	void exitInt(AParser.IntContext ctx);
 ```

ANTLR gives errors if an alternative name conflicts with a rule name. Here’s another rewrite of rule e where two alternative labels conflict with rule names:
如果选项名称与规则名称冲突，ANTLR 会报错。这是规则 e 的另一个重写版本，其中两个选项标签与规则名称冲突：

```
 	e : e '*' e # e
 	| e '+' e # Stat
 	| INT # Int
 	;
```

The context objects generated from rule names and labels get capitalized and so label Stat conflicts with rule stat:
从规则名称和标签生成的上下文对象会被大写，因此标签 Stat 与规则 stat 冲突：

```bash
 	$ antlr4 A.g4
 	error(124): A.g4:5:23: rule alt label e conflicts with rule e
 	error(124): A.g4:6:23: rule alt label Stat conflicts with rule stat
 	warning(125): A.g4:2:13: implicit definition of token INT in parser
```

## Rule Context Objects
## 规则上下文对象

ANTLR generates methods to access the rule context objects (parse tree nodes) associated with each rule reference. For rules with a single rule reference, ANTLR generates a method with no arguments. Consider the following rule.
ANTLR 生成方法来访问与每个规则引用关联的规则上下文对象（解析树节点）。对于具有单个规则引用的规则，ANTLR 生成一个无参数的方法。考虑以下规则。

```
 	inc : e '++' ;
```

ANTLR generates this context class:
ANTLR 生成此上下文类：

```java
public static class IncContext extends ParserRuleContext {
 	public EContext e() { ... } // return context object associated with e
 	...
}
```

ANTLR also provide support to access context objects when there is more than a single reference to a rule:
当存在对规则的多个引用时，ANTLR 还提供支持来访问上下文对象：

```
field : e '.' e ;
```

ANTLR generates a method with an index to access the ith element as well as a method to get context for all references to that rule:
ANTLR 生成一个带索引的方法来访问第 i 个元素，以及一个方法来获取对该规则所有引用的上下文：

```java
public static class FieldContext extends ParserRuleContext {
 	public EContext e(int i) { ... } // get ith e context
 	public List<EContext> e() { ... } // return ALL e contexts
 	...
}
```

If we had another rule, s, that references field, an embedded action could access the list of e rule matches performed by field:
如果我们有另一个规则 s 引用 field，则嵌入式操作可以访问由 field 执行的 e 规则匹配列表：

```
s : field
 	{
 	List<EContext> x = $field.ctx.e();
 	...
 	}
;
```

A listener or visitor could do the same thing. Given a pointer to a FieldContext object, f, f.e() would return List<EContext>.
监听器或访问者可以做同样的事情。给定一个指向 FieldContext 对象 f 的指针，f.e() 将返回 List<EContext>。

## Rule Element Labels
## 规则元素标签

You can label rule elements using the = operator to add fields to the rule context objects:
您可以使用 = 运算符标记规则元素，以向规则上下文对象添加字段：

```
stat: 'return' value=e ';' # Return
 	| 'break' ';' # Break
 	;
```

Here value is the label for the return value of rule e, which is defined elsewhere.
Labels become fields in the appropriate parse tree node class. In this case, label value becomes a field in ReturnContext because of the Return alternative label:
这里 value 是规则 e 返回值的标签，规则 e 在其他地方定义。
标签成为相应解析树节点类中的字段。在这种情况下，由于 Return 选项标签，标签 value 成为 ReturnContext 中的一个字段：

```java
public static class ReturnContext extends StatContext {
 	public EContext value;
 	...
}
```

It’s often handy to track a number of tokens, which you can do with the += "list label" operator. For example, the following rule creates a list of the Token objects matched for a simple array construct:
跟踪多个标记通常很方便，您可以使用 += "列表标签"运算符来实现。例如，以下规则为简单数组结构创建一个匹配的 Token 对象列表：

```
 	array : '{' el+=INT (',' el+=INT)* '}' ;
```

ANTLR generates a List field in the appropriate rule context class:
ANTLR 在相应的规则上下文类中生成一个 List 字段：

```
 	public static class ArrayContext extends ParserRuleContext {
 	public List<Token> el = new ArrayList<Token>();
 	...
 	}
```

These list labels also work for rule references:
这些列表标签也适用于规则引用：

```
 	elist : exprs+=e (',' exprs+=e)* ;
```

ANTLR generates a field holding the list of context objects:
ANTLR 生成一个包含上下文对象列表的字段：

```
 	public static class ElistContext extends ParserRuleContext {
 	public List<EContext> exprs = new ArrayList<EContext>();
 	...
 	}
```

## Rule Elements
## 规则元素

Rule elements specify what the parser should do at a given moment just like statements in a programming language. The elements can be rule, token, string literal like expression, ID, and 'return'. Here’s a complete list of the rule elements (we’ll look at actions and predicates in more detail later):
规则元素指定解析器在给定时刻应该做什么，就像编程语言中的语句一样。元素可以是规则、标记、字符串字面量，如 expression、ID 和 'return'。以下是规则元素的完整列表（我们将在后面更详细地讨论动作和断言）：

<table>
<tr>
<th>Syntax</th><th>Description</th>
</tr>
<tr>
<td>T</td><td>
Match token T at the current input position. Tokens always begin with a capital letter.</td>
</tr>
<tr>
<td>'literal'</td><td>
Match the string literal at the current input position. A string literal is simply a token with a fixed string.</td>
</tr>
<tr>
<td>r</td><td>
Match rule r at current input position, which amounts to invoking the rule just like a function call. Parser rule names always begin with a lowercase letter.</td>
</tr>
<tr>
<td>r [«args»]</td><td>
Match rule r at current input position, passing in a list of arguments just like a function call. The arguments inside the square brackets are in the syntax of the target language and are usually a comma-separated list of expressions.</td>
</tr>
<tr>
<td>{«action»}</td><td>
Execute an action immediately after the preceding alternative element and immediately before the following alternative element. The action conforms to the syntax of the target language. ANTLR copies the action code to the generated class verbatim, except for substituting attribute and token references such as $x and $x.y.</td>
</tr>
<tr>
<td>{«p»}?</td><td>
Evaluate semantic predicate «p». Do not continue parsing past a predicate if «p» evaluates to false at runtime. Predicates encountered during prediction, when ANTLR distinguishes between alternatives, enable or disable the alternative(s) surrounding the predicate(s).</td>
</tr>
<tr>
<td>.</td><td>
Match any single token except for the end of file token. The "dot" operator is called the wildcard.</td>
</tr>
</table>

When you want to match everything but a particular token or set of tokens, use the `~` "not" operator. This operator is rarely used in the parser but is available. `~INT` matches any token except the `INT` token. `~','` matches any token except the comma. `~(INT|ID)` matches any token except an INT or an ID.
当您想要匹配除特定标记或标记集之外的所有内容时，请使用 `~` "非"运算符。此运算符在解析器中很少使用，但可用。`~INT` 匹配除 `INT` 标记之外的任何标记。`~','` 匹配除逗号之外的任何标记。`~(INT|ID)` 匹配除 INT 或 ID 之外的任何标记。

Token, string literal, and semantic predicate rule elements can take options. See Rule Element Options.
标记、字符串字面量和语义断言规则元素可以接受选项。请参阅规则元素选项。

## Subrules
## 子规则

A rule can contain alternative blocks called subrules (as allowed in Extended BNF Notation: EBNF). A subrule is like a rule that lacks a name and is enclosed in parentheses. Subrules can have one or more alternatives inside the parentheses. Subrules cannot define attributes with locals and returns like rules can. There are four kinds of subrules (x, y, and z represent grammar fragments):
规则可以包含称为子规则的选项块（扩展巴科斯-诺尔范式 EBNF 中允许）。子规则类似于没有名称并用括号括起来的规则。子规则在括号内可以有一个或多个选项。子规则不能像规则那样定义带有局部变量和返回值的属性。有四种子规则（x、y 和 z 表示语法片段）：

<table>
<tr>
<th>Syntax</th><th>Description</th>
</tr>
<tr>
<td><img src=images/xyz.png></td><td>(x|y|z).
Match any alternative within the subrule exactly once. Example:
<br>
<tt>
returnType : (type | 'void') ;
</tt>
</td>
</tr>
<tr>
<td><img src=images/xyz_opt.png></td><td>(x|y|z)?
Match nothing or any alternative within subrule. Example:
<br>
<tt>	
classDeclaration
    : 'class' ID (typeParameters)? ('extends' type)?
      ('implements' typeList)?
 	   classBody
    ;
</tt>
<tr>
<td><img src=images/xyz_star.png></td><td>(x|y|z)*
Match an alternative within subrule zero or more times. Example:
<br>
<tt>
annotationName : ID ('.' ID)* ;
</tt>
</tr>
<tr>	
<td><img src=images/xyz_plus.png></td><td>(x|y|z)+
Match an alternative within subrule one or more times. Example:
<br>
<tt>
annotations : (annotation)+ ;
</tt>
</td>
</tr>
</table>

You can suffix the `?`, `*`, and `+` subrule operators with the nongreedy operator, which is also a question mark: `??`, `*?`, and `+?`. See Section 15.6, Wildcard Operator and Nongreedy Subrules.
您可以在 `?`、`*` 和 `+` 子规则运算符后附加非贪婪运算符（也是一个问号）：`??`、`*?` 和 `+?`。请参阅第 15.6 节"通配符运算符和非贪婪子规则"。

As a shorthand, you can omit the parentheses for subrules composed of a single alternative with a single rule element reference. For example, `annotation+` is the same as `(annotation)+` and `ID+` is the same as `(ID)+`. Labels also work with the shorthand. `ids+=INT+` make a list of `INT` token objects.
作为简写，对于由单个选项和单个规则元素引用组成的子规则，可以省略括号。例如，`annotation+` 与 `(annotation)+` 相同，`ID+` 与 `(ID)+` 相同。标签也适用于简写形式。`ids+=INT+` 创建一个 `INT` 标记对象列表。

## Catching Exceptions
## 捕获异常

When a syntax error occurs within a rule, ANTLR catches the exception, reports the error, attempts to recover (possibly by consuming more tokens), and then returns from the rule. Every rule is wrapped in a `try/catch/finally` statement:
当规则内发生语法错误时，ANTLR 会捕获异常，报告错误，尝试恢复（可能通过消耗更多标记），然后从规则返回。每个规则都包装在 `try/catch/finally` 语句中：

```
void r() throws RecognitionException {
 	try {
 		rule-body
 	}
 	catch (RecognitionException re) {
	 	_errHandler.reportError(this, re);
	 	_errHandler.recover(this, re);
 	}
 	finally {
		exitRule();
 	}
}
```

In Section 9.5, Altering ANTLR’s Error Handling Strategy, we saw how to use a strategy object to alter ANTLR’s error handling. Replacing the strategy changes the strategy for all rules, however. To alter the exception handling for a single rule, specify an exception after the rule definition:
在第 9.5 节"改变 ANTLR 的错误处理策略"中，我们看到了如何使用策略对象来改变 ANTLR 的错误处理。但是，替换策略会改变所有规则的策略。要改变单个规则的异常处理，请在规则定义后指定异常：

```
r : ...
  ;
  catch[RecognitionException e] { throw e; }
```

That example shows how to avoid default error reporting and recovery. r rethrows the exception, which is useful when it makes more sense for a higher-level rule to report the error. Specifying any exception clause, prevents ANTLR from generating a clause to handle `RecognitionException`.
该示例展示了如何避免默认的错误报告和恢复。r 重新抛出异常，当更高级别的规则报告错误更有意义时，这很有用。指定任何异常子句会阻止 ANTLR 生成处理 `RecognitionException` 的子句。

You can specify other exceptions as well:
您也可以指定其他异常：

```
r : ...
  ;
  catch[FailedPredicateException fpe] { ... }
  catch[RecognitionException e] { ... }
```

The code snippets inside curly braces and the exception "argument" actions must be written in the target language; Java, in this case.
When you need to execute an action even if an exception occurs, put it into the `finally` clause:
花括号内的代码片段和异常"参数"动作必须用目标语言编写；在这种情况下是 Java。
当您需要即使发生异常也要执行某个动作时，请将其放入 `finally` 子句中：

```
r : ...
  ;
  // catch blocks go first
  finally { System.out.println("exit rule r"); }
```

The finally clause executes right before the rule triggers `exitRule` before returning. If you want to execute an action after the rule finishes matching the alternatives but before it does its cleanup work, use an `after` action.
finally 子句在规则触发 `exitRule` 返回之前执行。如果您想在规则完成匹配选项之后但在执行清理工作之前执行某个动作，请使用 `after` 动作。

Here’s a complete list of exceptions:
以下是异常的完整列表：

<table>
<tr>
<th>Exception name</th><th>Description</th>
</tr>
<tr>
<td>RecognitionException</td><td>
The superclass of all exceptions thrown by an ANTLR-generated recognizer. It’s a subclass of RuntimeException to avoid the hassles of checked exceptions. This exception records where the recognizer (lexer or parser) was in the input, where it was in the ATN (internal graph data structure representing the grammar), the rule invocation stack, and what kind of problem occurred.</td>
</tr>
<tr>
<td>NoViableAltException</td><td>
Indicates that the parser could not decide which of two or more paths to take by looking at the remaining input. This exception tracks the starting token of the offending input and also knows where the parser was in the various paths when the error occurred.</td>
</tr>
<tr>
<td>LexerNoViableAltException</td><td>
The equivalent of NoViableAltException but for lexers only.</td>
</tr>
<tr>
<td>InputMismatchException</td><td>
The current input Token does not match what the parser expected.</td>
</tr>
<tr>
<td>FailedPredicateException</td><td>
A semantic predicate that evaluates to false during prediction renders the surrounding alternative nonviable. Prediction occurs when a rule is predicting which alternative to take. If all viable paths disappear, parser will throw NoViableAltException. This predicate gets thrown by the parser when a semantic predicate evaluates to false outside of prediction, during the normal parsing process of matching tokens and calling rules.</td>
</tr>
</table>

## Rule Attribute Definitions
## 规则属性定义

There are a number of action-related syntax elements associated with rules to be aware of. Rules can have arguments, return values, and local variables just like functions in a programming language. (Rules can have actions embedded among the rule elements, as we’ll see in Section 15.4, Actions and Attributes.) ANTLR collects all of the variables you define and stores them in the rule context object. These variables are usually called attributes. Here’s the general syntax showing all possible attribute definition locations:
有许多与动作相关的语法元素与规则相关联，需要注意。规则可以具有参数、返回值和局部变量，就像编程语言中的函数一样。（规则可以在规则元素之间嵌入动作，我们将在第 15.4 节"动作和属性"中看到。）ANTLR 收集您定义的所有变量并将它们存储在规则上下文对象中。这些变量通常称为属性。以下是显示所有可能属性定义位置的通用语法：

```
rulename[args] returns [retvals] locals [localvars] : ... ;
```

The attributes defined within those [...] can be used like any other variable. Here is a sample rule that copies parameters to return values:
在这些 [...] 内定义的属性可以像任何其他变量一样使用。以下是一个将参数复制到返回值的示例规则：

```
// Return the argument plus the integer value of the INT token
add[int x] returns [int result] : '+=' INT {$result = $x + $INT.int;} ;
```

The args, locals, and return `[...]` are generally in the target language but with some constraints. The `[...]` string is a comma-separated list of declarations either with prefix or postfix type notation or no-type notation. The elements can have initializer such as `[int x = 32, float y]` but don't go too crazy as we are parsing this generic text manually in [ScopeParser](https://github.com/antlr/antlr4/blob/master/tool/src/org/antlr/v4/parse/ScopeParser.java).  
args、locals 和 return `[...]` 通常使用目标语言，但有一些约束。`[...]` 字符串是一个逗号分隔的声明列表，可以使用前缀或后缀类型表示法或无类型表示法。元素可以有初始化器，例如 `[int x = 32, float y]`，但不要太过复杂，因为我们是在 [ScopeParser](https://github.com/antlr/antlr4/blob/master/tool/src/org/antlr/v4/parse/ScopeParser.java) 中手动解析此通用文本。

* Java, CSharp, C++ use `int x` notation but C++ must use a slightly altered notation for array references, `int[] x`, to fit in the *type* *id* syntax.
* Go and Swift give the type after the variable name, but Swift requires a `:` in between. Go `i int`, Swift `i:int`.  For Go target, you must either use `int i` or `i:int`.
* Python and JavaScript don't specify static types so actions are just identifier lists such as `[i,j]`.
* Java、CSharp、C++ 使用 `int x` 表示法，但 C++ 必须对数组引用使用稍微修改的表示法 `int[] x`，以符合 *类型* *标识符* 语法。
* Go 和 Swift 在变量名后给出类型，但 Swift 需要在中间加一个 `:`。Go `i int`，Swift `i:int`。对于 Go 目标，您必须使用 `int i` 或 `i:int`。
* Python 和 JavaScript 不指定静态类型，因此动作只是标识符列表，例如 `[i,j]`。

Technically any target could use either notation. For examples, see [TestScopeParsing](https://github.com/antlr/antlr4/blob/master/tool-testsuite/test/org/antlr/v4/test/tool/TestScopeParsing.java).
从技术上讲，任何目标都可以使用任一种表示法。有关示例，请参阅 [TestScopeParsing](https://github.com/antlr/antlr4/blob/master/tool-testsuite/test/org/antlr/v4/test/tool/TestScopeParsing.java)。

As with the grammar level, you can specify rule-level named actions. For rules, the valid names are `init` and `after`. As the names imply, parsers execute init actions immediately before trying to match the associated rule and execute after actions immediately after matching the rule. ANTLR after actions do not execute as part of the finally code block of the generated rule function. Use the ANTLR finally action to place code in the generated rule function finally code block.
与语法级别一样，您可以指定规则级别的命名动作。对于规则，有效的名称是 `init` 和 `after`。顾名思义，解析器在尝试匹配关联规则之前立即执行 init 动作，并在匹配规则之后立即执行 after 动作。ANTLR 的 after 动作不作为生成的规则函数 finally 代码块的一部分执行。使用 ANTLR 的 finally 动作将代码放置在生成的规则函数的 finally 代码块中。

The actions come after any argument, return value, or local attribute definition actions. The `row` rule preamble from Section 10.2, Accessing Token and Rule Attributes illustrates the syntax nicely:
动作位于任何参数、返回值或局部属性定义动作之后。第 10.2 节"访问标记和规则属性"中的 `row` 规则前导很好地说明了该语法：
actions/CSV.g4

```
/** Derived from rule "row : field (',' field)* '\r'? '\n' ;" */
row[String[] columns]
   returns [Map<String,String> values]
   locals [int col=0]
	@init {
	$values = new HashMap<String,String>();
	}
	@after {
	if ($values!=null && $values.size()>0) {
	System.out.println("values = "+$values);
	}
	}
	: ...
	;
```

Rule row takes argument columns, returns values, and defines local variable col. The "actions" in square brackets are copied directly into the generated code:
规则 row 接受参数 columns，返回值 values，并定义局部变量 col。方括号中的"动作"直接复制到生成的代码中：

```java
public class CSVParser extends Parser {
	...
	public static class RowContext extends ParserRuleContext {
		public String [] columns;
		public Map<String,String> values;
		public int col=0;
		...
	}
	...
}
```

The generated rule functions also specify the rule arguments as function arguments, but they are quickly copied into the local RowContext object:
生成的规则函数还将规则参数指定为函数参数，但它们会迅速复制到本地 RowContext 对象中：

```java
public class CSVParser extends Parser {
 	...
 	public final RowContext row(String [] columns) throws RecognitionException {
	 	RowContext _localctx = new RowContext(_ctx, 4, columns);
	 	enterRule(_localctx, RULE_row);
	 	...
 	}
 	...
}
```

ANTLR tracks nested `[...]` within the action so that `String[]` columns is parsed properly. It also tracks angle brackets so that commas within generic type parameters do not signify the start of another attribute. `Map<String,String>` values is one attribute definition.
ANTLR 跟踪动作内嵌套的 `[...]`，以便正确解析 `String[]` columns。它还跟踪尖括号，以便泛型类型参数内的逗号不表示另一个属性的开始。`Map<String,String>` values 是一个属性定义。

There can be multiple attributes in each action, even for return values. Use a comma to separate attributes within the same action:
每个动作中可以有多个属性，即使是返回值也是如此。使用逗号分隔同一动作内的属性：

```
a[Map<String,String> x, int y] : ... ;
```

ANTLR interprets that action to define two arguments, x and y:
ANTLR 将该动作解释为定义两个参数 x 和 y：

```java
public final AContext a(Map<String,String> x, int y)
	throws RecognitionException
{
	AContext _localctx = new AContext(_ctx, 0, x, y);
	enterRule(_localctx, RULE_a);
	...
}
```

## Start Rules and EOF
## 起始规则和 EOF

A start rule is the rule engaged first by the parser; it’s the rule function called by the language application. For example, a language application that parsed to Java code might call `parser.compilationUnit()` for a `JavaParser` object called `parser`. Any rule in the grammar can act as a start rule.
起始规则是解析器首先使用的规则；它是语言应用程序调用的规则函数。例如，解析 Java 代码的语言应用程序可能为名为 `parser` 的 `JavaParser` 对象调用 `parser.compilationUnit()`。语法中的任何规则都可以作为起始规则。

Start rules don’t necessarily consume all of the input. They consume only as much input as needed to match an alternative of the rule. For example, consider the following rule that matches one, two, or three tokens, depending on the input.
起始规则不一定会消耗所有输入。它们只消耗匹配规则选项所需的输入量。例如，考虑以下规则，它根据输入匹配一个、两个或三个标记。

```
s : ID
  | ID '+'
  | ID '+' INT
  ;
```

Upon `a+3`, rule `s` matches the third alternative. Upon `a+b`, it matches the second alternative and ignores the final `b` token. Upon `a b`, it matches the first alternative, ignoring the `b` token. The parser does not consume the complete input in the latter two cases because rule `s` doesn’t explicitly say that end of file must occur after matching an alternative of the rule.
对于 `a+3`，规则 `s` 匹配第三个选项。对于 `a+b`，它匹配第二个选项并忽略最后的 `b` 标记。对于 `a b`，它匹配第一个选项，忽略 `b` 标记。解析器在后两种情况下不消耗完整输入，因为规则 `s` 没有明确说明在匹配规则选项后必须出现文件结束符。

This default functionality is very useful for building things like IDEs. Imagine the IDE wanting to parse a method somewhere in the middle of a big Java file. Calling rule `methodDeclaration` should try to match just a method and ignore whatever comes next.
这种默认功能对于构建 IDE 等非常有用。想象一下 IDE 想要解析大型 Java 文件中间某个位置的方法。调用规则 `methodDeclaration` 应该只尝试匹配一个方法，而忽略后面的所有内容。

On the other hand, rules that describe entire input files should reference special predefined-token `EOF`. If they don’t, you might scratch your head for a while wondering why the start rule doesn’t report errors for any input no matter what you give it. Here’s a rule that’s part of a grammar for reading configuration files:
另一方面，描述整个输入文件的规则应引用特殊的预定义标记 `EOF`。如果不这样做，您可能会挠头一段时间，想知道为什么起始规则无论输入什么都不会报告错误。以下是一个用于读取配置文件的语法中的规则：

```
config : element*; // can "match" even with invalid input.
```

Invalid input would cause `config` to return immediately without matching any input and without reporting an error. Here’s the proper specification:
无效输入会导致 `config` 立即返回，而不匹配任何输入且不报告错误。以下是正确的规范：

```
file : element* EOF; // don't stop early. must match all input
```
