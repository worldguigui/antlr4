# Actions and Attributes
# 动作与属性

[原文链接](https://github.com/antlr/antlr4/blob/master/doc/actions.md)

In Chapter 10, Attributes and Actions, we learned how to embed actions within grammars and looked at the most common token and rule attributes. This section summarizes the important syntax and semantics from that chapter and provides a complete list of all available attributes. (You can learn more about actions in the grammar from the free excerpt on listeners and actions.)
在第10章"属性与动作"中，我们学习了如何在语法中嵌入动作，并查看了最常见的词法符号和规则属性。本节总结了该章节中的重要语法和语义，并提供了所有可用属性的完整列表。（您可以通过免费的监听器和动作摘录了解更多关于语法中的动作。）

Actions are blocks of text written in the target language and enclosed in curly braces. The recognizer triggers them according to their locations within the grammar. For example, the following rule emits "found a decl" after the parser has seen a valid declaration:
动作是用目标语言编写并用花括号括起来的文本块。识别器根据它们在语法中的位置触发它们。例如，以下规则在解析器看到有效的声明后输出"found a decl"：

```
decl: type ID ';' {System.out.println("found a decl");} ;
type: 'int' | 'float' ;
```

Most often, actions access the attributes of tokens and rule references:
大多数情况下，动作访问词法符号和规则引用的属性：

```
decl: type ID ';'
      {System.out.println("var "+$ID.text+":"+$type.text+";");}
    | t=ID id=ID ';'
      {System.out.println("var "+$id.text+":"+$t.text+";");}
    ;
```

## Token Attributes
## 词法符号属性

All tokens have a collection of predefined, read-only attributes. The attributes include useful token properties such as the token type and text matched for a token. Actions can access these attributes via `$label.attribute` where label labels a particular instance of a token reference (`a` and `b` in the example below are used in the action code as `$a` and `$b`). Often, a particular token is only referenced once in the rule, in which case the token name itself can be used unambiguously in the action code (token `INT` can be used as `$INT` in the action). The following example illustrates token attribute expression syntax:
所有词法符号都有一组预定义的只读属性。这些属性包括有用的词法符号属性，例如词法符号类型和匹配到的词法符号文本。动作可以通过 `$label.attribute` 访问这些属性，其中 label 标记了词法符号引用的特定实例（下例中的 `a` 和 `b` 在动作代码中用作 `$a` 和 `$b`）。通常，特定词法符号在规则中只被引用一次，在这种情况下，词法符号名称本身可以在动作代码中明确使用（词法符号 `INT` 可以在动作中用作 `$INT`）。以下示例说明了词法符号属性表达式语法：

```
r : INT {int x = $INT.line;}
    ( ID {if ($INT.line == $ID.line) ...;} )?
    a=FLOAT b=FLOAT {if ($a.line == $b.line) ...;}
  ;
```

The action within the `(...)?` subrule can see the `INT` token matched before it in the outer level.
`(...)?` 子规则内的动作可以看到外层级别中在它之前匹配的 `INT` 词法符号。

Because there are two references to the `FLOAT` token, a reference to `$FLOAT` in an action is not unique; you must use labels to specify which token reference you’re interested in.
由于有两个对 `FLOAT` 词法符号的引用，动作中对 `$FLOAT` 的引用不是唯一的；您必须使用标签来指定您感兴趣的是哪个词法符号引用。

Token references within different alternatives are unique because only one of them can be matched for any invocation of the rule. For example, in the following rule, actions in both alternatives can reference `$ID` directly without using a label:
不同选项中的词法符号引用是唯一的，因为对于规则的任何调用，只能匹配其中一个。例如，在以下规则中，两个选项中的动作都可以直接引用 `$ID` 而无需使用标签：

```
 	r : ... ID {System.out.println($ID.text);}
 	| ... ID {System.out.println($ID.text);}
 	;
```

To access the tokens matched for literals, you must use a label:
要访问为字面量匹配的词法符号，您必须使用标签：

```
 	stat: r='return' expr ';' {System.out.println("line="+$r.line);} ;
```

Most of the time you access the attributes of the token, but sometimes it is useful to access the Token object itself because it aggregates all the attributes. Further, you can use it to test whether an optional subrule matched a token:
大多数时候您访问的是词法符号的属性，但有时访问 Token 对象本身也很有用，因为它聚合了所有属性。此外，您可以使用它来测试可选子规则是否匹配了某个词法符号：

```
 	stat: 'if' expr 'then' stat (el='else' stat)?
 	{if ( $el!=null ) System.out.println("found an else");}
 	| ...
 	;
```

`$T` and `$L` evaluate to `Token` objects for token name `T` and token label `L`. `$ll` evaluates to `List<Token>` for list label `ll`. `$T.attr` evaluates to the type and value specified in the following table for attribute `attr`:
`$T` 和 `$L` 分别求值为词法符号名称 `T` 和词法符号标签 `L` 的 `Token` 对象。`$ll` 为列表标签 `ll` 求值为 `List<Token>`。`$T.attr` 为属性 `attr` 求值为下表中指定的类型和值：

|Attribute|Type|Description|
|---------|----|-----------|
|text|String|The text matched for the token; translates to a call to getText. Example: $ID.text.|
|type|int|The token type (nonzero positive integer) of the token such as INT; translates to a call to getType. Example: $ID.type.|
|line|int|The line number on which the token occurs, counting from 1; translates to a call to getLine. Example: $ID.line.|
|pos|int|The character position within the line at which the token’s first character occurs counting from zero; translates to a call to getCharPositionInLine. Example: $ID.pos.|
|index|int|The overall index of this token in the token stream, counting from zero; translates to a call to getTokenIndex. Example: $ID.index.|
|channel|int|The token’s channel number. The parser tunes to only one channel, effectively ignoring off-channel tokens. The default channel is 0 (Token.DEFAULT_CHANNEL), and the default hidden channel is Token.HIDDEN_CHANNEL. Translates to a call to getChannel. Example: $ID.channel.|
|int|int|The integer value of the text held by this token; it assumes that the text is a valid numeric string. Handy for building calculators and so on. Translates to Integer.valueOf(text-of-token). Example: $INT.int.|
|属性|类型|描述|
|---------|----|-----------|
|text|String|为该词法符号匹配的文本；转换为调用 getText。示例：$ID.text。|
|type|int|词法符号的类型（非零正整数），例如 INT；转换为调用 getType。示例：$ID.type。|
|line|int|词法符号所在的行号，从 1 开始计数；转换为调用 getLine。示例：$ID.line。|
|pos|int|词法符号首字符在行中的字符位置，从零开始计数；转换为调用 getCharPositionInLine。示例：$ID.pos。|
|index|int|该词法符号在词法符号流中的总体索引，从零开始计数；转换为调用 getTokenIndex。示例：$ID.index。|
|channel|int|词法符号的通道号。解析器只调谐到一个通道，有效忽略通道外词法符号。默认通道是 0 (Token.DEFAULT_CHANNEL)，默认隐藏通道是 Token.HIDDEN_CHANNEL。转换为调用 getChannel。示例：$ID.channel。|
|int|int|该词法符号所持有文本的整数值；它假定文本是有效的数字字符串。便于构建计算器等。转换为 Integer.valueOf(词法符号的文本)。示例：$INT.int。|

## Parser Rule Attributes
## 解析器规则属性

ANTLR predefines a number of read-only attributes associated with parser rule references that are available to actions. Actions can access rule attributes only for references that precede the action. The syntax is `$r.attr` for rule name `r` or a label assigned to a rule reference. For example, `$expr.text` returns the complete text matched by a preceding invocation of rule `expr`:
ANTLR 预定义了许多与解析器规则引用关联的只读属性，这些属性可用于动作。动作只能访问在它之前的规则引用的属性。语法是 `$r.attr`，其中 r 是规则名称或分配给规则引用的标签。例如，`$expr.text` 返回前一次调用规则 `expr` 所匹配的完整文本：

```
returnStat : 'return' expr {System.out.println("matched "+$expr.text);} ;
```

Using a rule label looks like this:
使用规则标签如下所示：

```
returnStat : 'return' e=expr {System.out.println("matched "+$e.text);} ;
```

You can also use `$` followed by the name of the attribute to access the value associated with the currently executing rule. For example, `$start` is the starting token of the current rule.
您也可以使用 `$` 后跟属性名称来访问与当前正在执行的规则关联的值。例如，`$start` 是当前规则的起始词法符号。

```
returnStat : 'return' expr {System.out.println("first token "+$start.getText());} ;
```

`$r` and `$rl` evaluate to `ParserRuleContext` objects of type `RContext` for rule name `r` and rule label `rl`. `$rll` evaluates to `List<RContext>` for rule list label `rll`. `$r.attr` evaluates to the type and value specified in the following table for attribute `attr`:
`$r` 和 `$rl` 分别求值为规则名称 `r` 和规则标签 `rl` 的 `RContext` 类型的 `ParserRuleContext` 对象。`$rll` 为规则列表标签 `rll` 求值为 `List<RContext>`。`$r.attr` 为属性 `attr` 求值为下表中指定的类型和值：

|Attribute|Type|Description|
|---------|----|-----------|
|text|String|The text matched for a rule or the text matched from the start of the rule up until the point of the `$text` expression evaluation. Note that this includes the text for all tokens including those on hidden channels, which is what you want because usually that has all the whitespace and comments. When referring to the current rule, this attribute is available in any action including any exception actions.|
|start|Token|The first token to be potentially matched by the rule that is on the main token channel; in other words, this attribute is never a hidden token. For rules that end up matching no tokens, this attribute points at the first token that could have been matched by this rule. When referring to the current rule, this attribute is available to any action within the rule.|
|stop|Token|The last nonhidden channel token to be matched by the rule. When referring to the current rule, this attribute is available only to the after and finally actions.|
|ctx|ParserRuleContext|The rule context object associated with a rule invocation. All of the other attributes are available through this attribute. For example, `$ctx.start` accesses the start field within the current rules context object. It’s the same as `$start`.|
|parser|Parser|The parser itself.  This attribute can be used, for example, to invoke a method defined in the parser's `@members` section from a semantic predicate.|
|属性|类型|描述|
|---------|----|-----------|
|text|String|为规则匹配的文本，或从规则开始直到 `$text` 表达式求值点所匹配的文本。请注意，这包括所有词法符号的文本，包括隐藏通道上的词法符号，这通常是您想要的，因为它通常包含所有空白和注释。当引用当前规则时，此属性在任何动作中都可用，包括任何异常动作。|
|start|Token|规则可能匹配的主词法符号通道上的第一个词法符号；换句话说，此属性永远不会是隐藏词法符号。对于最终没有匹配任何词法符号的规则，此属性指向本规则可能匹配的第一个词法符号。当引用当前规则时，此属性对规则内的任何动作可用。|
|stop|Token|规则匹配的最后一个非隐藏通道词法符号。当引用当前规则时，此属性仅对 after 和 finally 动作可用。|
|ctx|ParserRuleContext|与规则调用关联的规则上下文对象。所有其他属性都可通过此属性访问。例如，`$ctx.start` 访问当前规则上下文对象中的 start 字段。它与 `$start` 相同。|
|parser|Parser|解析器本身。例如，此属性可用于从语义谓词中调用解析器的 `@members` 部分中定义的方法。|

## Dynamically-Scoped Attributes
## 动态作用域属性

You can pass information to and from rules using parameters and return values, just like functions in a general-purpose programming language. Programming languages don’t allow functions to access the local variables or parameters of invoking functions, however. For example, the following reference to local variable `x` form a nested method call is illegal in Java:
您可以使用参数和返回值在规则之间传递信息，就像通用编程语言中的函数一样。但是，编程语言不允许函数访问调用函数的局部变量或参数。例如，以下在嵌套方法调用中引用局部变量 `x` 在 Java 中是非法的：

```java
void f() {
	int x = 0;
	g();
}
void g() {
	h();
}
void h() {
	int y = x; // INVALID reference to f's local variable x
}
```

Variable `x` is available only within the scope of `f`, which is the text lexically delimited by curly brackets. For this reason, Java is said to use lexical scoping. Lexical scoping is the norm for most programming languages. Languages that allow methods further down in the call chain to access local variables defined earlier are said to use dynamic scoping. The term dynamic refers to the fact that a compiler cannot statically determine the set of visible variables. This is because the set of variables visible to a method changes depending on who calls that method.
变量 `x` 仅在 `f` 的作用域内可用，该作用域是由花括号词法定界的文本。因此，Java 被称为使用词法作用域。词法作用域是大多数编程语言的规范。允许调用链中更下游的方法访问先前定义的局部变量的语言被称为使用动态作用域。术语"动态"指的是编译器无法静态确定可见变量集合。这是因为方法可见的变量集合会根据调用者而变化。

It turns out that, in the grammar realm, distant rules sometimes need to communicate with each other, mostly to provide context information to rules matched below in the rule invocation chain. (Naturally, this assumes that you are using actions directly in the grammar instead of the parse-tree listener event mechanism.) ANTLR allows dynamic scoping in that actions can access attributes from invoking rules using syntax `$r::x` where `r` is a rule name and `x` is an attribute within that rule. It is up to the programmer to ensure that `r` is in fact an invoking rule of the current rule. A runtime exception occurs if `r` is not in the current call chain when you access `$r::x`.
事实证明，在语法领域，远处的规则有时需要相互通信，主要是为了向规则调用链中下方匹配的规则提供上下文信息。（自然，这假设您直接在语法中使用动作，而不是解析树监听器事件机制。）ANTLR 允许动态作用域，即动作可以使用语法 `$r::x` 访问调用规则的属性，其中 `r` 是规则名称，`x` 是该规则内的属性。由程序员确保 `r` 实际上是当前规则的调用规则。如果在访问 `$r::x` 时 `r` 不在当前调用链中，则会发生运行时异常。

To illustrate the use of dynamic scoping, consider the real problem of defining variables and ensuring that variables in expressions are defined. The following grammar defines the symbols attribute where it belongs in the block rule but adds variable names to it in rule `decl`. Rule `stat` then consults the list to see whether variables have been defined.
为了说明动态作用域的使用，考虑定义变量并确保表达式中的变量已定义的实际问题。以下语法在 block 规则中定义了 symbols 属性，但在规则 `decl` 中向其中添加变量名称。然后规则 `stat` 查询该列表以查看变量是否已定义。

```
grammar DynScope;
 
prog: block ;
 
block
	/* List of symbols defined within this block */
	locals [
	List<String> symbols = new ArrayList<String>()
	]
	: '{' decl* stat+ '}'
	// print out all symbols found in block
	// $block::symbols evaluates to a List as defined in scope
	{System.out.println("symbols="+$symbols);}
	;
 
/** Match a declaration and add identifier name to list of symbols */
decl: 'int' ID {$block::symbols.add($ID.text);} ';' ;
 
/** Match an assignment then test list of symbols to verify
 * that it contains the variable on the left side of the assignment.
 * Method contains() is List.contains() because $block::symbols
 * is a List.
 */
stat: ID '=' INT ';'
	{
	if ( !$block::symbols.contains($ID.text) ) {
	System.err.println("undefined variable: "+$ID.text);
	}
	}
	| block
	;
 
ID : [a-z]+ ;
INT : [0-9]+ ;
WS : [ \t\r\n]+ -> skip ;
```

Here’s a simple build and test sequence:
以下是一个简单的构建和测试序列：

```bash
$ antlr4 DynScope.g4
$ javac DynScope*.java
$ grun DynScope prog
=> 	{
=> 	int i;
=> 	i = 0;
=> 	j = 3;
=> 	}
=> 	EOF
<= 	undefined variable: j
 	symbols=[i]
```

There’s an important difference between a simple field declaration in a `@members` action and dynamic scoping. symbols is a local variable and so there is a copy for each invocation of rule `block`. That’s exactly what we want for nested blocks so that we can reuse the same input variable name in an inner block. For example, the following nested code block redefines `i` in the inner scope. This new definition must hide the definition in the outer scope.
`@members` 动作中的简单字段声明与动态作用域有一个重要区别。symbols 是一个局部变量，因此每次调用规则 `block` 时都有一个副本。这正是我们对于嵌套块所希望的，这样我们就可以在内部块中重用相同的输入变量名。例如，以下嵌套代码块在内部作用域中重新定义了 `i`。这个新定义必须隐藏外部作用域中的定义。

```
{
	int i;
	int j;
	i = 0;
	{
		int i;
		int x;
		x = 5;
	}
	x = 3;
}
```

Here’s the output generated for that input by DynScope:
以下是 DynScope 为该输入生成的输出：

```bash
$ grun DynScope prog nested-input
symbols=[i, x]
undefined variable: x
symbols=[i, j]
```

Referencing `$block::symbols` accesses the `symbols` field of the most recently invoked `block`’s rule context object. If you need access to a symbols instance from a rule invocation farther up the call chain, you can walk backwards starting at the current context, `$ctx`. Use `getParent` to walk up the chain.
引用 `$block::symbols` 会访问最近调用的 `block` 规则上下文对象的 `symbols` 字段。如果您需要从调用链中更上层的规则调用访问 symbols 实例，您可以从当前上下文 `$ctx` 开始向后遍历。使用 `getParent` 向上遍历调用链。
