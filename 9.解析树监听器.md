# Parse Tree Listeners
# 解析树监听器

[原文链接](https://github.com/antlr/antlr4/blob/master/doc/listeners.md)

*Partially taken from publically visible [excerpt from ANTLR 4 book](http://media.pragprog.com/titles/tpantlr2/picture.md)*
*部分内容取自公开的 [ANTLR 4 书籍摘录](http://media.pragprog.com/titles/tpantlr2/picture.md)*

By default, ANTLR-generated parsers build a data structure called a parse tree or syntax tree that records how the parser recognized the structure of the input sentence and component phrases.
默认情况下，ANTLR 生成的解析器会构建一个称为解析树或语法树的数据结构，该结构记录了解析器如何识别输入句子及其组成短语的结构。

<img src=images/process.png>

The interior nodes of the parse tree are phrase names that group and identify their children. The root node is the most abstract phrase name, in this case `stat` (short for statement). The leaves of a parse tree are always the input tokens. Parse trees sit between a language recognizer and an interpreter or translator implementation. They are extremely effective data structures because they contain all of the input and complete knowledge of how the parser grouped the symbols into phrases. Better yet, they are easy to understand and the parser generates them automatically (unless you turn them off with `parser.setBuildParseTree(false)`).
解析树的内部节点是短语名称，用于分组和标识其子节点。根节点是最抽象的短语名称，在此例中为 `stat`（statement 的缩写）。解析树的叶子始终是输入词法符号。解析树位于语言识别器与解释器或翻译器实现之间。它们是极其有效的数据结构，因为它们包含所有输入以及解析器如何将符号分组为短语的完整知识。更好的是，它们易于理解，并且解析器会自动生成它们（除非您使用 `parser.setBuildParseTree(false)` 将其关闭）。

Because we specify phrase structure with a set of rules, parse tree subtree roots correspond to grammar rule names. ANTLR has a ParseTreeWalker that knows how to walk these parse trees and trigger events in listener implementation objects that you can create. The ANTLR tool generates listener interfaces for you also, unless you turn that off with a commandline option. You can also have it generate visitors. For example from a Java.g4 grammar, ANTLR generates:
因为我们使用一组规则来指定短语结构，所以解析树子树根对应于语法规则名称。ANTLR 有一个 ParseTreeWalker，它知道如何遍历这些解析树并在您创建的监听器实现对象中触发事件。ANTLR 工具也会为您生成监听器接口，除非您使用命令行选项将其关闭。您也可以让它生成访问者。例如，从 Java.g4 语法中，ANTLR 生成：

```java
public interface JavaListener extends ParseTreeListener<Token> {
  void enterClassDeclaration(JavaParser.ClassDeclarationContext ctx);
  void exitClassDeclaration(JavaParser.ClassDeclarationContext ctx);
  void enterMethodDeclaration(JavaParser.MethodDeclarationContext ctx);
 ...
}
```

where there is an enter and exit method for each rule in the parser grammar. ANTLR also generates a base listener with empty implementations of all listener interface methods, in this case called JavaBaseListener. You can build your listener by subclassing this base and overriding the methods of interest.
其中为解析器语法中的每个规则提供了 enter 和 exit 方法。ANTLR 还会生成一个基础监听器，其中包含所有监听器接口方法的空实现，在此例中称为 JavaBaseListener。您可以通过继承此基础类并覆盖感兴趣的方法来构建您的监听器。

Assuming you've created a listener object called `MyListener`, here is how to call the Java parser and walk the parse tree:
假设您创建了一个名为 `MyListener` 的监听器对象，以下是调用 Java 解析器并遍历解析树的方法：

```java
JavaLexer lexer = new JavaLexer(input);
CommonTokenStream tokens = new CommonTokenStream(lexer);
JavaParser parser = new JavaParser(tokens);
JavaParser.CompilationUnitContext tree = parser.compilationUnit(); // parse a compilationUnit

MyListener extractor = new MyListener(parser);
ParseTreeWalker.DEFAULT.walk(extractor, tree); // initiate walk of tree with listener in use of default walker
```

Listeners and visitors are great because they keep application-specific code out of grammars, making grammars easier to read and preventing them from getting entangled with a particular application.
监听器和访问者的优点在于它们将应用程序特定代码与语法分离，使语法更易于阅读，并防止它们与特定应用程序纠缠在一起。

See the book for more information on listeners and to learn how to use visitors. (The biggest difference between the listener and visitor mechanisms is that listener methods are called independently by an ANTLR-provided walker object, whereas visitor methods must walk their children with explicit visit calls.  Forgetting to invoke visitor methods on a node’s children, means those subtrees don’t get visited.)
有关监听器的更多信息以及学习如何使用访问者，请参阅书籍。（监听器和访问者机制之间的最大区别在于，监听器方法由 ANTLR 提供的遍历器对象独立调用，而访问者方法必须通过显式的访问调用来遍历其子节点。忘记在节点的子节点上调用访问者方法意味着这些子树不会被访问。）

## Listening during the parse
## 在解析过程中监听

We can also use listeners to execute code during the parse instead of waiting for a tree walker walks the resulting parse tree. Let's say we have the following simple expression grammar.
我们也可以使用监听器在解析过程中执行代码，而不是等待树遍历器遍历生成的解析树。假设我们有以下简单的表达式语法。

```
grammar CalcNoLR;

s : expr EOF ;

expr:	add ((MUL | DIV) add)* ;

add :   atom ((ADD | SUB) atom)* ;

atom : INT ;

INT : [0-9]+;
MUL : '*';
DIV : '/';
ADD : '+';
SUB : '-';
WS : [ \t]+ -> channel(HIDDEN);
```

We can create a listener that executes during the parse by implementing the listener interface as before:
我们可以通过像之前一样实现监听器接口来创建一个在解析期间执行的监听器：

```java
class CountListener extends CalcNoLRBaseListener {
	public int nums = 0;
	public boolean execExitS = false;

	@Override
	public void exitS(CalcNoLRParser.SContext ctx) {
		execExitS = true;
	}

	@Override
	public void exitAtom(CalcNoLRParser.AtomContext ctx) {
		nums++;
	}
}
```

And then passing it to `addParseListener()`:
然后将其传递给 `addParseListener()`：

```java
String input = "2 + 8 / 2";
CalcNoLRLexer lexer = new CalcNoLRLexer(new ANTLRInputStream(input));
CalcNoLRParser parser = new CalcNoLRParser(new CommonTokenStream(lexer));
CountListener counter = new CountListener();
parser.addParseListener(counter);

// Check that the purses valid first
CalcNoLRParser.SContext context = parser.s();
String parseTreeS = context.toStringTree(parser);
assertEquals("(s (expr (add (atom 2) + (atom 8)) / (add (atom 2))) <EOF>)", parseTreeS);
assertEquals(3, counter.nums);
assertEquals(true, counter.execExitS);
```

One should not do very complicated work during the parse because the parser is throwing exception to handle syntax errors. If you're complicated code throws different kind of exception it will screw up the parsing and things will go nuts. If you want to catch and properly handle exceptions in your listener code during the parse, you should override this method from `Parser`:
在解析期间不应执行非常复杂的工作，因为解析器会抛出异常来处理语法错误。如果您的复杂代码抛出不同类型的异常，将会扰乱解析过程，导致问题。如果您想在解析期间捕获并正确处理监听器代码中的异常，您应该重写 `Parser` 中的这个方法：

```java
protected boolean listenerExceptionOccurred = false;

/**
 * Notify any parse listeners of an exit rule event.
 *
 * @see #addParseListener
 */
@override
protected void triggerExitRuleEvent() {
	if ( listenerExceptionOccurred ) return;
	try {
		// reverse order walk of listeners
		for (int i = _parseListeners.size() - 1; i >= 0; i--) {
			ParseTreeListener listener = _parseListeners.get(i);
			_ctx.exitRule(listener);
			listener.exitEveryRule(_ctx);
		}
	}
	catch (Throwable e) {
		// If an exception is thrown in the user's listener code, we need to bail out
		// completely out of the parser, without executing anymore user code. We
		// must also stop the parse otherwise other listener actions will attempt to execute
		// almost certainly with invalid results. So, record the fact an exception occurred
		listenerExceptionOccurred = true;
		throw e;
	}
}
```

Now, if you throw an exception inside one of the listener methods:
现在，如果您在其中一个监听器方法中抛出异常：

```java
// Now throw an exception in the listener
class ErrorListener extends CalcNoLRBaseListener {
	public boolean execExitS = false;
	public boolean execExitAtom = false;

	@Override
	public void exitS(CalcNoLRParser.SContext ctx) {
		execExitS = true;
	}

	@Override
	public void exitAtom(CalcNoLRParser.AtomContext ctx) {
		execExitAtom = true;
		throw new NullPointerException("bail out");
	}
}
```

then the exception will properly cause the parser to bailout and the exception will not be thrown out:
那么异常将正确导致解析器退出，并且异常不会被抛出：

```
java.lang.NullPointerException: bail out

	at org.antlr.v4.test.runtime.java.api.TestParseListener$2ErrorListener.exitAtom(TestParseListener.java:102)
	at org.antlr.v4.test.runtime.java.api.CalcNoLRParser$AtomContext.exitRule(CalcNoLRParser.java:311)
	at org.antlr.v4.runtime.Parser.triggerExitRuleEvent(Parser.java:412)
	at org.antlr.v4.runtime.Parser.exitRule(Parser.java:654)
	at org.antlr.v4.test.runtime.java.api.CalcNoLRParser.atom(CalcNoLRParser.java:336)
	at org.antlr.v4.test.runtime.java.api.CalcNoLRParser.add(CalcNoLRParser.java:261)
	at org.antlr.v4.test.runtime.java.api.CalcNoLRParser.expr(CalcNoLRParser.java:181)
	at org.antlr.v4.test.runtime.java.api.CalcNoLRParser.s(CalcNoLRParser.java:123)
```
